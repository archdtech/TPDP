#!/bin/bash

# BMAD-METHOD‚Ñ¢ Workflow Script for TPDP Security Project
# Implements agentic planning and context-engineered development

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script variables
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
BMAD_CORE_DIR="$PROJECT_DIR/.bmad-core"
BMAD_AGENTS_DIR="$PROJECT_DIR/bmad-agents"
DOCS_DIR="$PROJECT_DIR/docs"

log() {
    echo -e "${GREEN}[BMAD-WORKFLOW]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[BMAD-WORKFLOW]${NC} $1"
}

error() {
    echo -e "${RED}[BMAD-WORKFLOW]${NC} $1"
    exit 1
}

info() {
    echo -e "${BLUE}[BMAD-WORKFLOW]${NC} $1"
}

success() {
    echo -e "${PURPLE}[BMAD-WORKFLOW]${NC} $1"
}

# Function to check if we're in the project directory
check_project_dir() {
    if [[ ! -f "$BMAD_CORE_DIR/core-config.yaml" ]]; then
        error "Not in TPDP project directory. Missing .bmad-core/core-config.yaml"
    fi
}

# Function to setup BMAD-METHOD‚Ñ¢ structure
setup_bmad_structure() {
    log "Setting up BMAD-METHOD‚Ñ¢ structure for TPDP Security Project..."
    
    # Create necessary directories
    mkdir -p "$DOCS_DIR"/{prd,architecture,epics,stories,qa/{assessments,gates},security,planning}
    mkdir -p "$BMAD_CORE_DIR"/{templates,tasks,checklists,data}
    mkdir -p "$BMAD_AGENTS_DIR"
    mkdir -p "$PROJECT_DIR"/logs/backups
    
    # Create basic templates
    create_templates
    
    # Create task files
    create_tasks
    
    success "BMAD-METHOD‚Ñ¢ structure setup complete"
}

# Function to create BMAD templates
create_templates() {
    log "Creating BMAD-METHOD‚Ñ¢ templates..."
    
    # Security PRD Template
    cat > "$BMAD_CORE_DIR/templates/security-prd-template.md" << 'EOF'
# Security Product Requirements Document
## TPDP Security Foundation & Architecture Enhancement

### üìã Project Overview
**Project Name**: TPDP Security Foundation & Architecture Enhancement  
**Project ID**: TPDP-SECURE-2024-001  
**Priority**: CRITICAL  
**Framework**: BMAD-METHOD‚Ñ¢  

### üéØ Executive Summary
[Brief description of the security project and its business impact]

### üîí Security Vision
[Describe the target security state and vision]

### üìä Current Security State
[Document current security vulnerabilities and risks]

### üéØ Security Objectives
[List specific security objectives and goals]

### üìã Security Requirements

#### Functional Requirements
- [FR-001] [Specific security functionality requirement]
- [FR-002] [Specific security functionality requirement]

#### Non-Functional Requirements
- [NFR-001] [Security performance requirement]
- [NFR-002] [Security compliance requirement]

#### Security Constraints
- [Constraint-001] [Technical or business constraint]

### üèóÔ∏è Security Architecture Overview
[High-level security architecture description]

### üìÖ Implementation Timeline
[Phased implementation plan with timeline]

### üéØ Success Metrics
[Measurable security success criteria]

### üìä Risk Assessment
[Security risk analysis and mitigation strategies]

### üë• Stakeholders
[List key stakeholders and their roles]

### üîÑ Dependencies
[List technical and business dependencies]

---
*Generated by BMAD-METHOD‚Ñ¢ Security PM Agent*
EOF

    # Security Architecture Template
    cat > "$BMAD_CORE_DIR/templates/security-architecture-template.md" << 'EOF'
# Security Architecture Document
## TPDP Security Foundation & Architecture Enhancement

### üèóÔ∏è Architecture Overview
**Document Version**: v4.0  
**Security Level**: Enterprise  
**Compliance Framework**: SOC2, GDPR, HIPAA  

### üéØ Architecture Goals
[Define security architecture goals and objectives]

### üîê Authentication Architecture
#### Current State
[Describe current authentication vulnerabilities]

#### Target Architecture
[Design secure authentication architecture]
- **Technology**: NextAuth.js v4
- **Protocol**: OAuth 2.0 + JWT
- **Storage**: HTTP-only cookies
- **Security**: bcrypt password hashing

#### Implementation Details
[Detailed authentication implementation specifications]

### üõ°Ô∏è Authorization Architecture
#### Current State
[Describe current authorization weaknesses]

#### Target Architecture
[Design enterprise-grade authorization framework]
- **Model**: Role-Based Access Control (RBAC)
- **Implementation**: Server-side permission validation
- **Database**: Prisma with foreign key constraints
- **UI**: Role-based component rendering

#### Implementation Details
[Detailed authorization implementation specifications]

### üóÑÔ∏è Database Security Architecture
#### Current State
[Describe current database security issues]

#### Target Architecture
[Design secure database architecture]
- **ORM**: Prisma with security constraints
- **Encryption**: Field-level encryption for sensitive data
- **Access**: Role-based database access
- **Auditing**: Comprehensive audit logging

#### Implementation Details
[Detailed database security implementation specifications]

### üåê API Security Architecture
#### Current State
[Describe current API security vulnerabilities]

#### Target Architecture
[Design secure API architecture]
- **Authentication**: JWT validation middleware
- **Authorization**: Permission-based access control
- **Validation**: Input sanitization and output encoding
- **Monitoring**: API security event logging

#### Implementation Details
[Detailed API security implementation specifications]

### üîÑ Session Security Architecture
#### Current State
[Describe current session management vulnerabilities]

#### Target Architecture
[Design secure session management]
- **Storage**: HTTP-only cookies
- **Duration**: Configurable session timeout
- **Validation**: Server-side session validation
- **Revocation**: Secure session invalidation

#### Implementation Details
[Detailed session security implementation specifications]

### üèóÔ∏è Security Infrastructure
#### Deployment Architecture
[Design secure deployment infrastructure]
- **Environment**: Secure configuration management
- **Network**: Security zones and firewalls
- **Monitoring**: Security event monitoring
- **Backup**: Secure backup and recovery

#### Security Controls
[List specific security controls and mechanisms]

### üìä Security Compliance
#### Regulatory Requirements
[Document compliance requirements and mapping]

#### Security Standards
[List applicable security standards and frameworks]

#### Audit Requirements
[Define security audit and logging requirements]

### üéØ Implementation Strategy
#### Phased Approach
[Describe phased implementation strategy]

#### Migration Strategy
[Plan for secure migration from current to target state]

#### Testing Strategy
[Security testing and validation approach]

### üîß Technical Specifications
#### Technology Stack
[Detailed technology stack and security considerations]

#### Security Patterns
[Security design patterns and best practices]

#### Performance Considerations
[Security-performance trade-offs and optimizations]

---
*Generated by BMAD-METHOD‚Ñ¢ Security Architect Agent*
EOF

    # Security Story Template
    cat > "$BMAD_CORE_DIR/templates/security-story-template.md" << 'EOF'
# Security Development Story
## [Story Title]

### üìã Story Information
**Story ID**: [STORY-ID]  
**Epic**: [EPIC-ID]  
**Priority**: [PRIORITY]  
**Estimate**: [STORY-POINTS]  
**Security Level**: [SECURITY-LEVEL]  

### üéØ Security Context
**Threat Model**: [Relevant threat model references]  
**Compliance Requirements**: [Applicable compliance requirements]  
**Security Constraints**: [Security implementation constraints]  

### üìã Security Requirements
#### Functional Security Requirements
- [Requirement 1]: [Specific security functionality]
- [Requirement 2]: [Specific security functionality]

#### Non-Functional Security Requirements
- [Requirement 1]: [Security performance or compliance requirement]
- [Requirement 2]: [Security reliability requirement]

### üèóÔ∏è Technical Architecture
#### Component Overview
[Description of security components and their interactions]

#### Security Patterns
[Security design patterns to be implemented]

#### Integration Points
[How this security component integrates with existing system]

### üîß Implementation Details
#### Technical Specifications
- **Technology**: [Specific technologies and frameworks]
- **Dependencies**: [Security dependencies and libraries]
- **Configuration**: [Security configuration requirements]

#### Security Implementation
[Detailed security implementation steps and considerations]

#### Code Structure
[Expected code structure and file organization]

### üß™ Security Testing
#### Test Requirements
- [Test 1]: [Specific security test requirement]
- [Test 2]: [Specific security test requirement]

#### Validation Criteria
[Specific security validation criteria and acceptance tests]

#### Security Scenarios
[Security test scenarios and edge cases]

### üìä Security Considerations
#### Threat Mitigation
[How this story mitigates specific security threats]

#### Compliance Verification
[How this story ensures compliance requirements are met]

#### Performance Impact
[Security-performance considerations and trade-offs]

### üîÑ Integration Requirements
#### Dependencies
[Technical and functional dependencies]

#### Data Flow
[Security data flow and transformation requirements]

#### Error Handling
[Security error handling and failure modes]

### üìã Acceptance Criteria
#### Security Acceptance Criteria
- [ ] [Specific security acceptance criterion]
- [ ] [Specific security acceptance criterion]

#### Functional Acceptance Criteria
- [ ] [Specific functional acceptance criterion]
- [ ] [Specific functional acceptance criterion]

#### Performance Acceptance Criteria
- [ ] [Specific performance acceptance criterion]
- [ ] [Specific performance acceptance criterion]

### üìö Documentation Requirements
#### Security Documentation
- [ ] [Security documentation requirement]
- [ ] [Security documentation requirement]

#### Technical Documentation
- [ ] [Technical documentation requirement]
- [ ] [Technical documentation requirement]

### üéØ Success Metrics
#### Security Metrics
- [Metric 1]: [Specific security success metric]
- [Metric 2]: [Specific security success metric]

#### Quality Metrics
- [Metric 1]: [Specific quality success metric]
- [Metric 2]: [Specific quality success metric]

---
*Generated by BMAD-METHOD‚Ñ¢ Security Scrum Master Agent*
EOF

    success "BMAD-METHOD‚Ñ¢ templates created"
}

# Function to create task files
create_tasks() {
    log "Creating BMAD-METHOD‚Ñ¢ task files..."
    
    # Security Threat Analysis Task
    cat > "$BMAD_CORE_DIR/tasks/security-threat-analysis.md" << 'EOF'
# Security Threat Analysis Task

## Task Overview
Conduct comprehensive security threat analysis for TPDP project components.

## Execution Steps

### 1. System Analysis
- Analyze current TPDP authentication system
- Identify security vulnerabilities in localStorage usage
- Assess session management weaknesses
- Evaluate authorization bypass risks

### 2. Threat Modeling
- Apply STRIDE threat modeling methodology
- Identify potential attack vectors
- Assess impact of security vulnerabilities
- Prioritize threats based on risk level

### 3. Compliance Assessment
- Review applicable compliance frameworks
- Identify compliance gaps
- Assess regulatory requirements
- Document compliance risks

### 4. Risk Assessment
- Calculate risk scores using DREAD model
- Determine business impact
- Estimate likelihood of exploitation
- Prioritize remediation efforts

### 5. Mitigation Strategy
- Develop threat mitigation strategies
- Recommend security controls
- Suggest implementation priorities
- Create risk treatment plan

## Output Requirements
- Comprehensive threat analysis report
- Risk assessment with prioritization
- Mitigation recommendations
- Compliance gap analysis

## Quality Gates
- All critical vulnerabilities identified
- Risk assessment completed
- Mitigation strategies defined
- Compliance requirements addressed

## Dependencies
- TPDP system documentation
- Security framework requirements
- Compliance regulations
- Threat intelligence sources

## Elicitation Requirements
- Review threat analysis findings with security architect
- Validate risk assessment with enterprise architect
- Confirm mitigation priorities with project stakeholders
---
EOF

    # Security PRD Creation Task
    cat > "$BMAD_CORE_DIR/tasks/create-security-prd.md" << 'EOF'
# Security PRD Creation Task

## Task Overview
Create comprehensive Product Requirements Document for TPDP security project.

## Execution Steps

### 1. Requirements Gathering
- Collect security requirements from stakeholders
- Analyze threat analysis results
- Review compliance requirements
- Identify business security needs

### 2. Requirements Analysis
- Categorize requirements by type (functional, non-functional)
- Prioritize based on risk and business impact
- Define acceptance criteria
- Establish success metrics

### 3. PRD Structure
- Executive summary and business case
- Security vision and objectives
- Detailed requirements specification
- Implementation timeline and milestones

### 4. Stakeholder Review
- Present PRD to enterprise architect
- Gather feedback and revisions
- Secure stakeholder approval
- Finalize requirements document

### 5. PRD Finalization
- Incorporate stakeholder feedback
- Finalize requirements and acceptance criteria
- Create supporting documentation
- Prepare for architecture phase

## Output Requirements
- Complete PRD document
- Requirements traceability matrix
- Stakeholder approval documentation
- Supporting analysis documents

## Quality Gates
- All security requirements identified
- Stakeholder consensus achieved
- Requirements are testable and measurable
- Business case clearly articulated

## Dependencies
- Security threat analysis
- Stakeholder input
- Compliance requirements
- Business objectives

## Elicitation Requirements
- Present PRD structure to enterprise architect
- Review requirements prioritization
- Confirm acceptance criteria
- Validate timeline and milestones
---
EOF

    success "BMAD-METHOD‚Ñ¢ task files created"
}

# Function to initialize BMAD-METHOD‚Ñ¢ planning phase
init_planning_phase() {
    log "Initializing BMAD-METHOD‚Ñ¢ Planning Phase..."
    
    check_project_dir
    
    # Create planning directory structure
    mkdir -p "$DOCS_DIR/planning"
    
    # Start with security analyst agent
    info "Starting with Security Analyst agent for threat research..."
    info "Security Analyst will:"
    info "  1. Conduct comprehensive threat analysis"
    info "  2. Research compliance requirements"
    info "  3. Create security brief"
    info "  4. Assess current vulnerabilities"
    
    # Then security PM agent
    info "Continuing with Security PM agent for requirements..."
    info "Security PM will:"
    info "  1. Create security PRD"
    info "  2. Prioritize requirements"
    info "  3. Create epics and stories"
    info "  4. Develop project plan"
    
    # Then security architect agent
    info "Continuing with Security Architect agent for technical design..."
    info "Security Architect will:"
    info "  1. Design authentication architecture"
    info "  2. Create authorization framework"
    info "  3. Design security infrastructure"
    info "  4. Create architecture document"
    
    # Finally security QA agent
    info "Concluding with Security QA agent for test strategy..."
    info "Security QA will:"
    info "  1. Define security testing strategy"
    info "  2. Create test plans"
    info "  3. Define quality gates"
    info "  4. Establish validation criteria"
    
    success "Planning phase initialized. Agents ready to collaborate."
}

# Function to start development phase
init_development_phase() {
    log "Initializing BMAD-METHOD‚Ñ¢ Development Phase..."
    
    check_project_dir
    
    # Check if planning phase is complete
    if [[ ! -f "$DOCS_DIR/prd.md" ]] || [[ ! -f "$DOCS_DIR/architecture.md" ]]; then
        error "Planning phase incomplete. Missing PRD or Architecture document."
    fi
    
    # Create development directory structure
    mkdir -p "$DOCS_DIR/stories"
    
    # Start with security scrum master agent
    info "Starting with Security Scrum Master agent for story creation..."
    info "Security Scrum Master will:"
    info "  1. Shard PRD and Architecture documents"
    info "  2. Create detailed security stories"
    info "  3. Embed full context in stories"
    info "  4. Prepare development backlog"
    
    # Then security dev agents
    info "Continuing with Security Dev agents for implementation..."
    info "Security Dev agents will:"
    info "  1. Implement security features"
    info "  2. Follow architectural specifications"
    info "  3. Apply security best practices"
    info "  4. Create secure code"
    
    # Then security QA agents
    info "Continuing with Security QA agents for testing..."
    info "Security QA agents will:"
    info "  1. Execute security tests"
    info "  2. Validate security requirements"
    info "  3. Verify compliance"
    info "  4. Apply quality gates"
    
    # Finally security scrum master for review
    info "Concluding with Security Scrum Master for review..."
    info "Security Scrum Master will:"
    info "  1. Review implementation"
    info "  2. Refine stories as needed"
    info "  3. Manage quality gates"
    info "  4. Coordinate completion"
    
    success "Development phase initialized. Ready for context-engineered development."
}

# Function to run security analysis
run_security_analysis() {
    log "Running Security Analysis..."
    
    check_project_dir
    
    # This would typically invoke the security analyst agent
    info "Invoking Security Analyst agent..."
    info "Security Analyst will perform:"
    info "  - Threat analysis"
    info "  - Vulnerability assessment"
    info "  - Compliance research"
    info "  - Security brief creation"
    
    # For now, create a placeholder for the analysis
    cat > "$DOCS_DIR/planning/security-analysis.md" << 'EOF'
# Security Analysis Report
## Generated by Security Analyst Agent

### üîç Threat Analysis Summary
- **Authentication Vulnerabilities**: Critical - localStorage usage
- **Session Management**: Critical - XSS vulnerabilities
- **Authorization Risks**: High - Header spoofing possible
- **Data Protection**: Medium - Encryption needed

### üìã Compliance Requirements
- **SOC2 Type II**: Access controls, monitoring, audit trails
- **GDPR**: Data protection, user consent, right to access
- **HIPAA**: PHI protection, audit requirements, access controls

### üéØ Risk Assessment
- **Critical Risk**: Account takeover through localStorage
- **High Risk**: Session hijacking, privilege escalation
- **Medium Risk**: Data exposure, compliance violations

### üìä Security Brief
TPDP requires immediate security foundation improvements to address critical vulnerabilities and establish enterprise-grade security posture.

---
*Analysis completed by Security Analyst Agent*
EOF
    
    success "Security analysis completed. See $DOCS_DIR/planning/security-analysis.md"
}

# Function to create security PRD
create_security_prd() {
    log "Creating Security PRD..."
    
    check_project_dir
    
    # This would typically invoke the security PM agent
    info "Invoking Security PM agent..."
    info "Security PM will create comprehensive PRD based on:"
    info "  - Security analysis results"
    info "  - Stakeholder requirements"
    info "  - Business objectives"
    info "  - Compliance needs"
    
    # Create PRD document
    cat > "$DOCS_DIR/prd.md" << 'EOF'
# Security Product Requirements Document
## TPDP Security Foundation & Architecture Enhancement

### üìã Project Overview
**Project Name**: TPDP Security Foundation & Architecture Enhancement  
**Project ID**: TPDP-SECURE-2024-001  
**Priority**: CRITICAL  
**Framework**: BMAD-METHOD‚Ñ¢  
**Timeline**: 6 weeks  

### üéØ Executive Summary
TPDP currently operates with critical security vulnerabilities including localStorage-based authentication, no real authentication system, insecure session management, and no server-side authorization. These vulnerabilities pose significant business risk including account takeover, data breaches, and compliance violations. This project will transform TPDP into an enterprise-grade TPRM platform with robust security foundations.

### üîí Security Vision
Transform TPDP from a vulnerable TPRP platform into a secure, enterprise-grade system that:
- Implements industry-standard authentication and authorization
- Protects sensitive data through encryption and access controls
- Maintains comprehensive audit trails for compliance
- Provides role-based access control for different user types
- Ensures security by design and by default

### üìä Current Security State
**Critical Vulnerabilities Identified:**
1. **üî¥ CRITICAL: Basic Password Protection**
   - **Issue**: Using simple localStorage-based authentication
   - **Risk**: Account takeover, session hijacking
   - **Impact**: Complete system compromise

2. **üî¥ CRITICAL: No Real Authentication System**
   - **Issue**: NextAuth.js installed but not implemented
   - **Risk**: No secure authentication mechanism
   - **Impact**: Unauthorized access to sensitive data

3. **üî¥ CRITICAL: Insecure Session Management**
   - **Issue**: Client-side storage vulnerable to XSS attacks
   - **Risk**: Session theft, privilege escalation
   - **Impact**: Data breaches, compliance violations

4. **üî¥ CRITICAL: No Server-Side Authorization**
   - **Issue**: Header-based role detection easily spoofable
   - **Risk**: Privilege escalation, access control bypass
   - **Impact**: Unauthorized system access

### üéØ Security Objectives

#### Primary Objectives
- **OBJ-001**: Implement secure authentication system using NextAuth.js
- **OBJ-002**: Establish enterprise-grade authorization framework (RBAC)
- **OBJ-003**: Deploy secure session management with HTTP-only cookies
- **OBJ-004**: Create comprehensive audit logging system
- **OBJ-005**: Ensure compliance with SOC2, GDPR, and HIPAA

#### Secondary Objectives
- **OBJ-006**: Improve user experience while maintaining security
- **OBJ-007**: Provide security monitoring and alerting
- **OBJ-008**: Create security documentation and training
- **OBJ-009**: Establish security incident response procedures
- **OBJ-010**: Integrate security into development lifecycle

### üìã Security Requirements

#### Functional Requirements

**Authentication (FR-AUTH)**
- **FR-AUTH-001**: Implement NextAuth.js with credentials provider
- **FR-AUTH-002**: Use bcrypt for password hashing (minimum 12 rounds)
- **FR-AUTH-003**: Support JWT sessions with configurable timeout
- **FR-AUTH-004**: Implement secure password recovery mechanism
- **FR-AUTH-005**: Provide multi-factor authentication readiness
- **FR-AUTH-006**: Support user registration and management
- **FR-AUTH-007**: Implement session invalidation on logout
- **FR-AUTH-008**: Provide authentication error handling

**Authorization (FR-AUTHZ)**
- **FR-AUTHZ-001**: Implement Role-Based Access Control (RBAC)
- **FR-AUTHZ-002**: Define roles: Admin, Risk Analyst, Vendor Manager, Compliance Officer, Executive, Readonly
- **FR-AUTHZ-003**: Create permission system with granular controls
- **FR-AUTHZ-004**: Implement server-side permission validation
- **FR-AUTHZ-005**: Provide role management interface
- **FR-AUTHZ-006**: Support permission inheritance and composition
- **FR-AUTHZ-007**: Implement authorization middleware
- **FR-AUTHZ-008**: Provide access denied handling

**Session Management (FR-SESS)**
- **FR-SESS-001**: Use HTTP-only cookies for session storage
- **FR-SESS-002**: Implement secure session timeout (configurable)
- **FR-SESS-003**: Provide session monitoring and alerting
- **FR-SESS-004**: Implement concurrent session control
- **FR-SESS-005**: Support session revocation
- **FR-SESS-006**: Provide session audit logging
- **FR-SESS-007**: Implement secure session renewal
- **FR-SESS-008**: Handle session errors gracefully

**Database Security (FR-DB)**
- **FR-DB-001**: Implement Prisma with security constraints
- **FR-DB-002**: Create user and role models with proper relationships
- **FR-DB-003**: Implement field-level encryption for sensitive data
- **FR-DB-004**: Create audit logging model and triggers
- **FR-DB-005**: Implement database access controls
- **FR-DB-006**: Provide data backup and recovery
- **FR-DB-007**: Implement data validation and sanitization
- **FR-DB-008**: Support database migration security

**API Security (FR-API)**
- **FR-API-001**: Implement JWT validation middleware
- **FR-API-002**: Create input validation and sanitization
- **FR-API-003**: Implement output encoding for XSS prevention
- **FR-API-004**: Provide API rate limiting and throttling
- **FR-API-005**: Implement API security monitoring
- **FR-API-006**: Create API documentation with security notes
- **FR-API-007**: Support API versioning and deprecation
- **FR-API-008**: Implement API error handling

#### Non-Functional Requirements

**Security Performance (NF-PERF)**
- **NF-PERF-001**: Authentication response time < 500ms
- **NF-PERF-002**: Authorization validation < 100ms
- **NF-PERF-003**: Session validation < 50ms
- **NF-PERF-004**: Database query response < 200ms
- **NF-PERF-005**: API response time < 300ms
- **NF-PERF-006**: Support 100+ concurrent users
- **NF-PERF-007**: Maintain performance under load
- **NF-PERF-008**: Provide performance monitoring

**Security Compliance (NF-COMPL)**
- **NF-COMPL-001**: Comply with SOC2 Type II requirements
- **NF-COMPL-002**: Meet GDPR data protection standards
- **NF-COMPL-003**: Satisfy HIPAA security requirements
- **NF-COMPL-004**: Implement PCI DSS controls if applicable
- **NF-COMPL-005**: Provide compliance documentation
- **NF-COMPL-006**: Support compliance audits
- **NF-COMPL-007**: Maintain compliance evidence
- **NF-COMPL-008**: Provide compliance reporting

**Security Reliability (NF-REL)**
- **NF-REL-001**: Achieve 99.9% authentication uptime
- **NF-REL-002**: Maintain 99.5% authorization accuracy
- **NF-REL-003**: Ensure 100% session security
- **NF-REL-004**: Provide 99.9% data integrity
- **NF-REL-005**: Implement fault-tolerant security
- **NF-REL-006**: Provide security failover
- **NF-REL-007**: Maintain security under failure
- **NF-REL-008**: Support security recovery

**Security Usability (NF-USAB)**
- **NF-USAB-001**: Provide intuitive security interfaces
- **NF-USAB-002**: Minimize security friction for users
- **NF-USAB-003**: Offer clear security feedback
- **NF-USAB-004**: Support security education
- **NF-USAB-005**: Provide security help and support
- **NF-USAB-006**: Maintain security transparency
- **NF-USAB-007**: Support security preferences
- **NF-USAB-008**: Provide security customization

#### Security Constraints
- **CONSTR-001**: Must use NextAuth.js for authentication
- **CONSTR-002**: Must implement server-side authorization
- **CONSTR-003**: Must use Prisma ORM with SQLite
- **CONSTR-004**: Must maintain existing TPRP functionality
- **CONSTR-005**: Must comply with enterprise security standards
- **CONSTR-006**: Must support existing user roles and permissions
- **CONSTR-007**: Must provide backward compatibility where possible
- **CONSTR-008**: Must integrate with existing UI components

### üèóÔ∏è Security Architecture Overview

#### Authentication Architecture
- **Technology**: NextAuth.js v4 with credentials provider
- **Protocol**: OAuth 2.0 + JWT sessions
- **Storage**: HTTP-only cookies with secure flags
- **Security**: bcrypt password hashing, JWT validation
- **Integration**: Seamless integration with existing UI

#### Authorization Architecture
- **Model**: Role-Based Access Control (RBAC)
- **Implementation**: Server-side permission validation
- **Database**: Prisma models with foreign key constraints
- **UI**: Role-based component rendering and access control
- **Management**: Administrative interface for role and permission management

#### Session Security Architecture
- **Storage**: HTTP-only cookies, server-side session validation
- **Timeout**: Configurable session timeout with refresh
- **Security**: CSRF protection, session hijacking prevention
- **Monitoring**: Session activity logging and alerting
- **Management**: Session revocation and monitoring interface

#### Database Security Architecture
- **ORM**: Prisma with security constraints and validation
- **Encryption**: Field-level encryption for sensitive data
- **Access**: Role-based database access controls
- **Auditing**: Comprehensive audit logging for all operations
- **Backup**: Secure backup and recovery procedures

### üìÖ Implementation Timeline

#### Phase 1: Security Foundation (Week 1-2)
- **Week 1**: NextAuth.js implementation, secure session management
- **Week 2**: Password hashing, security headers, client-side auth removal

#### Phase 2: Database Architecture (Week 2-3)
- **Week 2**: TPRM schema design, Prisma migrations
- **Week 3**: Relationship implementation, audit logging

#### Phase 3: Authorization System (Week 3-4)
- **Week 3**: Server-side RBAC, permission management
- **Week 4**: Authorization components, security testing

#### Phase 4: Admin System (Week 4-5)
- **Week 4**: Admin dashboard, user management
- **Week 5**: Role management, system monitoring

#### Phase 5: Development Infrastructure (Week 5-6)
- **Week 5**: CI/CD pipeline, git workflow
- **Week 6**: Team training, documentation completion

### üéØ Success Metrics

#### Technical Security Metrics
- **SEC-001**: Zero critical security vulnerabilities
- **SEC-002**: 100% authentication success rate
- **SEC-003**: 99.9% authorization accuracy
- **SEC-004**: 100% session security compliance
- **SEC-005**: Complete audit trail coverage

#### Business Security Metrics
- **SEC-006**: 100% compliance requirement achievement
- **SEC-007**: 50% reduction in security-related incidents
- **SEC-008**: 100% user security satisfaction
- **SEC-009**: 70% improvement in admin task efficiency
- **SEC-010**: Zero security-related downtime

#### Process Security Metrics
- **SEC-011**: 100% security test pass rate
- **SEC-012**: 80% security code coverage
- **SEC-013**: 100% security documentation completeness
- **SEC-014**: 90% reduction in security implementation time
- **SEC-015**: 100% security gate compliance

### üìä Risk Assessment

#### Risk Analysis
- **High Risk**: Account takeover through localStorage manipulation
- **High Risk**: Session hijacking through XSS vulnerabilities
- **Medium Risk**: Privilege escalation through header spoofing
- **Medium Risk**: Data breach through insufficient encryption
- **Low Risk**: Compliance violations through inadequate audit trails

#### Mitigation Strategies
- **Immediate**: Implement NextAuth.js with secure sessions
- **Short-term**: Deploy RBAC authorization framework
- **Medium-term**: Enhance monitoring and alerting
- **Long-term**: Establish security operations center

### üë• Stakeholders

#### Primary Stakeholders
- **Enterprise Architect**: Project sponsor and technical oversight
- **Security Lead**: Security implementation and validation
- **Development Team**: Technical implementation and testing
- **Business Stakeholders**: Requirements and impact assessment

#### Secondary Stakeholders
- **Compliance Team**: Regulatory requirements and validation
- **Operations Team**: Deployment and monitoring
- **End Users**: Security experience and feedback
- **Audit Team**: Security audit and compliance verification

### üîÑ Dependencies

#### Technical Dependencies
- **Next.js 15**: Framework compatibility and security features
- **TypeScript 5**: Type safety and security constraints
- **Prisma ORM**: Database security and relationships
- **NextAuth.js v4**: Authentication and session management
- **shadcn/ui**: Secure UI components and integration

#### Business Dependencies
- **Security Requirements**: Stakeholder security needs and objectives
- **Compliance Requirements**: Regulatory and compliance mandates
- **Resource Availability**: Security expertise and development capacity
- **Timeline Constraints**: Business urgency and implementation schedule

#### External Dependencies
- **Security Frameworks**: OWASP, NIST, ISO 27001
- **Compliance Regulations**: SOC2, GDPR, HIPAA
- **Security Tools**: Vulnerability scanners, testing frameworks
- **Security Expertise**: External security consultants and auditors

---
*Generated by BMAD-METHOD‚Ñ¢ Security PM Agent*
EOF
    
    success "Security PRD created. See $DOCS_DIR/prd.md"
}

# Function to create security architecture
create_security_architecture() {
    log "Creating Security Architecture..."
    
    check_project_dir
    
    # This would typically invoke the security architect agent
    info "Invoking Security Architect agent..."
    info "Security Architect will create comprehensive architecture based on:"
    info "  - Security PRD requirements"
    info "  - Technical constraints and capabilities"
    info "  - Security best practices and patterns"
    info "  - Compliance and regulatory requirements"
    
    # Create architecture document
    cat > "$DOCS_DIR/architecture.md" << 'EOF'
# Security Architecture Document
## TPDP Security Foundation & Architecture Enhancement

### üèóÔ∏è Architecture Overview
**Document Version**: v4.0  
**Security Level**: Enterprise  
**Compliance Framework**: SOC2, GDPR, HIPAA  
**Architecture Date**: $(date +%Y-%m-%d)  

### üéØ Architecture Goals
Transform TPDP from a vulnerable TPRP platform into a secure, enterprise-grade TPRM system with:
- Industry-standard authentication and authorization
- Robust session management and data protection
- Comprehensive audit logging and compliance
- Role-based access control and administration
- Security monitoring and incident response

### üîê Authentication Architecture

#### Current State Analysis
**Critical Vulnerabilities:**
- **Storage**: localStorage for authentication data
- **Validation**: Client-side only, easily spoofable
- **Session**: No secure session management
- **Password**: No proper hashing or validation

**Attack Surface:**
- XSS attacks can steal localStorage data
- Direct access to authentication data
- No protection against session hijacking
- Vulnerable to credential stuffing attacks

#### Target Architecture Design

**Technology Stack:**
```typescript
// Authentication Technology Stack
{
  "framework": "NextAuth.js v4",
  "protocol": "OAuth 2.0 + JWT",
  "storage": "HTTP-only cookies",
  "hashing": "bcrypt (12 rounds)",
  "validation": "Server-side + client-side",
  "session": "Secure session management",
  "recovery": "Secure password reset"
}
```

**Core Components:**

1. **NextAuth.js Configuration**
```typescript
// NextAuth.js Configuration
export const authConfig = {
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        // Server-side validation and authentication
        const user = await authenticateUser(credentials);
        return user ? {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role
        } : null;
      }
    })
  ],
  session: {
    strategy: "jwt" as const,
    maxAge: 24 * 60 * 60, // 24 hours
    updateAge: 24 * 60 * 60 // 24 hours
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.role = user.role;
        token.permissions = user.permissions;
      }
      return token;
    },
    async session({ session, token }) {
      session.user.role = token.role;
      session.user.permissions = token.permissions;
      return session;
    }
  },
  pages: {
    signIn: "/auth/signin",
    signOut: "/auth/signout",
    error: "/auth/error"
  },
  secret: process.env.NEXTAUTH_SECRET,
  secureCookies: process.env.NODE_ENV === "production"
};
```

2. **Secure Session Management**
```typescript
// Session Security Implementation
export class SessionSecurity {
  private jwtService: JWTService;
  private cookieService: CookieService;
  private auditService: AuditService;

  async createSession(user: User): Promise<Session> {
    const sessionToken = await this.jwtService.sign({
      userId: user.id,
      role: user.role,
      permissions: user.permissions
    });

    const session = {
      id: generateUUID(),
      userId: user.id,
      sessionToken,
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      createdAt: new Date(),
      lastActiveAt: new Date()
    };

    // Store session in database
    await this.prisma.session.create({
      data: session
    });

    // Set HTTP-only cookie
    this.cookieService.setSecureCookie('auth-token', sessionToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60
    });

    // Audit log session creation
    await this.auditService.log({
      action: 'SESSION_CREATED',
      userId: user.id,
      sessionId: session.id,
      metadata: {
        userAgent: request.headers.get('user-agent'),
        ipAddress: request.ip
      }
    });

    return session;
  }
}
```

3. **Password Security**
```typescript
// Password Security Implementation
export class PasswordSecurity {
  private bcrypt: BCrypt;
  private validator: PasswordValidator;

  async hashPassword(password: string): Promise<string> {
    // Validate password strength
    await this.validator.validate(password);

    // Hash with bcrypt (12 rounds)
    const hash = await this.bcrypt.hash(password, 12);

    return hash;
  }

  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return await this.bcrypt.compare(password, hash);
  }

  async generateResetToken(): Promise<string> {
    // Generate secure reset token
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

    // Store reset token
    await this.prisma.passwordReset.create({
      data: {
        token,
        expiresAt,
        used: false
      }
    });

    return token;
  }
}
```

**Security Controls:**
- **Storage**: HTTP-only cookies with secure flags
- **Validation**: Server-side authentication with client-side validation
- **Encryption**: JWT with strong secret key
- **Session**: Secure session management with timeout
- **Password**: bcrypt with 12 rounds of hashing
- **Recovery**: Secure password reset mechanism

### üõ°Ô∏è Authorization Architecture

#### Current State Analysis
**Critical Weaknesses:**
- **Authorization**: Header-based role detection, easily spoofable
- **Permissions**: No granular permission system
- **Validation**: Client-side only, no server-side checks
- **Management**: No role or permission management interface

**Security Risks:**
- Privilege escalation through header manipulation
- Unauthorized access to restricted functionality
- No audit trail for authorization decisions
- Inability to manage user permissions effectively

#### Target Architecture Design

**RBAC Framework:**
```typescript
// RBAC Framework Design
export interface Role {
  id: string;
  name: string;
  description: string;
  permissions: Permission[];
  createdAt: Date;
  updatedAt: Date;
}

export interface Permission {
  id: string;
  name: string;
  description: string;
  resource: string;
  action: string;
  conditions?: PermissionCondition[];
}

export interface PermissionCondition {
  field: string;
  operator: 'equals' | 'contains' | 'in' | 'greater_than';
  value: any;
}

// Role Definition
export const ROLES = {
  ADMIN: {
    name: 'admin',
    description: 'System administrator with full access',
    permissions: ['*'] // Wildcard for all permissions
  },
  RISK_ANALYST: {
    name: 'risk_analyst',
    description: 'Risk management specialist',
    permissions: [
      'view_risk_assessments',
      'create_risk_assessments',
      'edit_risk_assessments',
      'view_vendors'
    ]
  },
  VENDOR_MANAGER: {
    name: 'vendor_manager',
    description: 'Vendor management specialist',
    permissions: [
      'view_vendors',
      'create_vendors',
      'edit_vendors',
      'view_vendor_assessments',
      'manage_vendor_relationships'
    ]
  },
  COMPLIANCE_OFFICER: {
    name: 'compliance_officer',
    description: 'Compliance and audit specialist',
    permissions: [
      'view_compliance_reports',
      'generate_compliance_reports',
      'view_audit_trails',
      'manage_compliance_settings'
    ]
  },
  EXECUTIVE: {
    name: 'executive',
    description: 'Executive with oversight access',
    permissions: [
      'view_dashboards',
      'view_reports',
      'view_audit_trails',
      'manage_users'
    ]
  },
  READONLY: {
    name: 'readonly',
    description: 'Read-only access for viewing',
    permissions: [
      'view_dashboards',
      'view_reports'
    ]
  }
};
```

**Authorization Middleware:**
```typescript
// Authorization Middleware Implementation
export class AuthorizationMiddleware {
  private permissionService: PermissionService;
  private auditService: AuditService;

  async requirePermission(permission: string, options: AuthorizationOptions = {}) {
    return async (request: NextRequest, context: any) => {
      const session = await getServerSession(authConfig);
      
      if (!session?.user?.role) {
        throw new AuthorizationError('Authentication required');
      }

      const hasPermission = await this.permissionService.hasPermission(
        session.user.role,
        permission,
        {
          userId: session.user.id,
          resource: options.resource,
          action: options.action,
          context: options.context
        }
      );

      if (!hasPermission) {
        // Audit log authorization failure
        await this.auditService.log({
          action: 'AUTHORIZATION_FAILED',
          userId: session.user.id,
          metadata: {
            requiredPermission: permission,
            userRole: session.user.role,
            resource: options.resource,
            action: options.action,
            userAgent: request.headers.get('user-agent'),
            ipAddress: request.ip
          }
        });

        throw new AuthorizationError('Access denied');
      }

      // Audit log authorization success
      await this.auditService.log({
        action: 'AUTHORIZATION_SUCCESS',
        userId: session.user.id,
        metadata: {
          grantedPermission: permission,
          userRole: session.user.role,
          resource: options.resource,
          action: options.action,
          userAgent: request.headers.get('user-agent'),
          ipAddress: request.ip
        }
      });

      return context;
    };
  }
}
```

**Permission Service:**
```typescript
// Permission Service Implementation
export class PermissionService {
  private prisma: PrismaClient;

  async hasPermission(
    roleName: string,
    requiredPermission: string,
    context: PermissionContext = {}
  ): Promise<boolean> {
    // Get role with permissions
    const role = await this.prisma.role.findUnique({
      where: { name: roleName },
      include: {
        permissions: true
      }
    });

    if (!role) {
      return false;
    }

    // Check for wildcard permission
    const hasWildcard = role.permissions.some(p => p.name === '*');
    if (hasWildcard) {
      return true;
    }

    // Check specific permission
    const hasPermission = role.permissions.some(p => p.name === requiredPermission);
    if (!hasPermission) {
      return false;
    }

    // Check conditional permissions
    if (context.resource && context.action) {
      return await this.checkConditionalPermissions(role, context);
    }

    return true;
  }

  private async checkConditionalPermissions(
    role: Role,
    context: PermissionContext
  ): Promise<boolean> {
    const conditionalPermissions = role.permissions.filter(p => p.conditions);

    for (const permission of conditionalPermissions) {
      if (permission.conditions) {
        const conditionsMet = await this.evaluateConditions(
          permission.conditions,
          context
        );
        if (!conditionsMet) {
          return false;
        }
      }
    }

    return true;
  }

  private async evaluateConditions(
    conditions: PermissionCondition[],
    context: PermissionContext
  ): Promise<boolean> {
    for (const condition of conditions) {
      const contextValue = this.getContextValue(context, condition.field);
      const conditionMet = this.evaluateCondition(
        condition.operator,
        contextValue,
        condition.value
      );
      if (!conditionMet) {
        return false;
      }
    }
    return true;
  }
}
```

**Security Controls:**
- **Authorization**: Server-side permission validation
- **Roles**: Predefined roles with specific permissions
- **Permissions**: Granular permission system with conditions
- **Audit**: Comprehensive authorization logging
- **Management**: Administrative interface for role/permission management

### üóÑÔ∏è Database Security Architecture

#### Current State Analysis
**Security Issues:**
- **Storage**: No encryption for sensitive data
- **Access**: No role-based database access controls
- **Auditing**: No comprehensive audit logging
- **Validation**: Limited input validation and sanitization

**Data Risks:**
- Sensitive data exposure through lack of encryption
- Unauthorized database access through weak controls
- No audit trail for data access and modifications
- Data integrity issues through lack of validation

#### Target Architecture Design

**Database Schema Security:**
```prisma
// Prisma Schema with Security
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  password  String   // bcrypt hashed
  roleId    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  role       Role       @relation(fields: [roleId], references: [id])
  sessions   Session[]
  auditLogs  AuditLog[]
  userProfile UserProfile?

  @@map("users")
}

model Role {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  permissions Permission[]
  users       User[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@map("roles")
}

model Permission {
  id          String             @id @default(cuid())
  name        String             @unique
  description String?
  resource    String
  action      String
  conditions  Json?
  roles       Role[]
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@map("permissions")
}

model Session {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String?
  action      String
  resource    String?
  resourceId  String?
  metadata    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  // Relationships
  user User? @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

model UserProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  firstName String?
  lastName  String?
  phone     String?
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}
```

**Data Encryption Service:**
```typescript
// Data Encryption Implementation
export class DataEncryptionService {
  private encryptionKey: string;
  private algorithm: string = 'aes-256-gcm';

  constructor() {
    this.encryptionKey = process.env.ENCRYPTION_KEY || '';
    if (!this.encryptionKey) {
      throw new Error('Encryption key not configured');
    }
  }

  async encrypt(data: string): Promise<EncryptedData> {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, this.encryptionKey);
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      algorithm: this.algorithm
    };
  }

  async decrypt(encryptedData: EncryptedData): Promise<string> {
    const decipher = crypto.createDecipher(
      this.algorithm,
      this.encryptionKey
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

interface EncryptedData {
  encrypted: string;
  iv: string;
  authTag: string;
  algorithm: string;
}
```

**Database Access Control:**
```typescript
// Database Access Control
export class DatabaseAccessControl {
  private prisma: PrismaClient;
  private permissionService: PermissionService;

  async queryWithAccessControl(
    userId: string,
    query: any,
    options: AccessControlOptions = {}
  ): Promise<any> {
    // Check user permissions
    const hasAccess = await this.permissionService.hasPermission(
      userId,
      'database_access',
      {
        resource: options.resource,
        action: options.action || 'read'
      }
    );

    if (!hasAccess) {
      throw new AccessDeniedError('Database access denied');
    }

    // Apply row-level security filters
    const filteredQuery = this.applyRowLevelSecurity(query, userId, options);

    // Execute query with audit logging
    const result = await this.prisma.$queryRawUnsafe(filteredQuery.sql, filteredQuery.params);

    // Audit database access
    await this.auditDatabaseAccess(userId, query, options);

    return result;
  }

  private applyRowLevelSecurity(query: any, userId: string, options: AccessControlOptions): any {
    // Apply row-level security based on user role and permissions
    // This is a simplified example - real implementation would be more complex
    const userRole = this.getUserRole(userId);
    
    if (userRole === 'readonly') {
      // Read-only users can only read data
      if (options.action && options.action !== 'read') {
        throw new AccessDeniedError('Read-only access');
      }
    }

    return query;
  }

  private async auditDatabaseAccess(
    userId: string,
    query: any,
    options: AccessControlOptions
  ): Promise<void> {
    await this.prisma.auditLog.create({
      data: {
        userId,
        action: 'DATABASE_ACCESS',
        resource: options.resource,
        metadata: {
          query: query.sql,
          options,
          timestamp: new Date().toISOString()
        }
      }
    });
  }
}
```

**Security Controls:**
- **Encryption**: Field-level encryption for sensitive data
- **Access Control**: Role-based database access controls
- **Auditing**: Comprehensive audit logging for all database operations
- **Validation**: Input validation and sanitization
- **Integrity**: Referential integrity and data consistency

### üåê API Security Architecture

#### Current State Analysis
**Security Vulnerabilities:**
- **Authentication**: No API authentication mechanism
- **Authorization**: No API access controls
- **Validation**: Limited input validation and output encoding
- **Monitoring**: No API security monitoring or logging

**API Risks:**
- Unauthorized API access and data exposure
- Injection attacks through insufficient validation
- Data manipulation through lack of access controls
- No audit trail for API operations

#### Target Architecture Design

**API Security Middleware:**
```typescript
// API Security Middleware Stack
export class APISecurityMiddleware {
  private authService: AuthenticationService;
  private authorizationService: AuthorizationService;
  private validationService: ValidationService;
  private auditService: AuditService;

  // Authentication Middleware
  authenticate = async (request: NextRequest): Promise<AuthenticatedUser> => {
    const token = this.extractToken(request);
    
    if (!token) {
      throw new AuthenticationError('Missing authentication token');
    }

    const user = await this.authService.validateToken(token);
    
    if (!user) {
      throw new AuthenticationError('Invalid authentication token');
    }

    return user;
  };

  // Authorization Middleware
  authorize = (permission: string) => {
    return async (request: NextRequest, user: AuthenticatedUser) => {
      const hasPermission = await this.authorizationService.hasPermission(
        user.role,
        permission,
        {
          resource: request.nextUrl.pathname,
          method: request.method
        }
      );

      if (!hasPermission) {
        throw new AuthorizationError('Access denied');
      }

      return user;
    };
  };

  // Input Validation Middleware
  validate = (schema: any) => {
    return async (request: NextRequest) => {
      const body = await request.json();
      
      try {
        const validated = await schema.parse(body);
        return validated;
      } catch (error) {
        throw new ValidationError('Invalid input data', error);
      }
    };
  };

  // Output Encoding Middleware
  encodeOutput = (data: any) => {
    return JSON.stringify(data, null, 2);
  };

  // Security Headers Middleware
  securityHeaders = () => {
    const headers = new Headers();
    
    // Security headers
    headers.set('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self'");
    headers.set('X-Content-Type-Options', 'nosniff');
    headers.set('X-Frame-Options', 'DENY');
    headers.set('X-XSS-Protection', '1; mode=block');
    headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    return headers;
  };
}
```

**API Route Security:**
```typescript
// Secure API Route Example
export async function POST(request: NextRequest) {
  try {
    // Apply security middleware
    const user = await securityMiddleware.authenticate(request);
    await securityMiddleware.authorize('create_user')(request, user);
    const validatedData = await securityMiddleware.validate(userSchema)(request);

    // Process request
    const result = await userService.createUser(validatedData);

    // Apply output encoding
    const encodedResponse = securityMiddleware.encodeOutput(result);
    
    // Apply security headers
    const headers = securityMiddleware.securityHeaders();

    return new Response(encodedResponse, {
      status: 201,
      headers
    });
  } catch (error) {
    // Handle security errors
    if (error instanceof AuthenticationError) {
      return new Response(
        JSON.stringify({ error: 'Authentication failed' }),
        { status: 401 }
      );
    }
    
    if (error instanceof AuthorizationError) {
      return new Response(
        JSON.stringify({ error: 'Access denied' }),
        { status: 403 }
      );
    }
    
    if (error instanceof ValidationError) {
      return new Response(
        JSON.stringify({ error: 'Validation failed', details: error.details }),
        { status: 400 }
      );
    }

    // Log security incidents
    await auditService.logSecurityIncident(error, request);

    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500 }
    );
  }
}
```

**Rate Limiting and Throttling:**
```typescript
// API Rate Limiting
export class RateLimiter {
  private redis: Redis;
  private windowSize: number = 60000; // 1 minute
  private maxRequests: number = 100;

  async checkRateLimit(userId: string, endpoint: string): Promise<boolean> {
    const key = `rate_limit:${userId}:${endpoint}`;
    const current = await this.redis.incr(key);
    
    if (current === 1) {
      await this.redis.expire(key, this.windowSize / 1000);
    }
    
    return current <= this.maxRequests;
  }

  async getRateLimitStatus(userId: string, endpoint: string): Promise<{
    remaining: number;
    reset: number;
  }> {
    const key = `rate_limit:${userId}:${endpoint}`;
    const current = parseInt(await this.redis.get(key) || '0');
    const ttl = await this.redis.ttl(key);
    
    return {
      remaining: Math.max(0, this.maxRequests - current),
      reset: ttl > 0 ? Date.now() + ttl * 1000 : 0
    };
  }
}
```

**Security Controls:**
- **Authentication**: JWT-based API authentication
- **Authorization**: Permission-based API access control
- **Validation**: Comprehensive input validation and sanitization
- **Encoding**: Output encoding to prevent XSS
- **Headers**: Security headers for protection
- **Rate Limiting**: API rate limiting and throttling
- **Monitoring**: API security monitoring and logging

### üîÑ Session Security Architecture

#### Current State Analysis
**Session Vulnerabilities:**
- **Storage**: Client-side localStorage, vulnerable to XSS
- **Management**: No session timeout or invalidation
- **Security**: No session hijacking protection
- **Monitoring**: No session activity monitoring

**Session Risks:**
- Session theft through XSS attacks
- Session fixation vulnerabilities
- No session timeout or invalidation
- Lack of session monitoring and alerting

#### Target Architecture Design

**Secure Session Management:**
```typescript
// Secure Session Management
export class SessionManager {
  private jwtService: JWTService;
  private redis: Redis;
  private auditService: AuditService;

  async createSession(user: User, request: NextRequest): Promise<Session> {
    // Generate session token
    const sessionToken = await this.jwtService.sign({
      userId: user.id,
      role: user.role,
      permissions: user.permissions,
      sessionId: generateUUID()
    });

    // Create session record
    const session = {
      id: generateUUID(),
      userId: user.id,
      sessionToken,
      expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
      createdAt: new Date(),
      lastActiveAt: new Date(),
      ipAddress: request.ip,
      userAgent: request.headers.get('user-agent'),
      isActive: true
    };

    // Store session in Redis for fast access
    await this.redis.setex(
      `session:${session.id}`,
      24 * 60 * 60, // 24 hours
      JSON.stringify(session)
    );

    // Store session in database for persistence
    await this.prisma.session.create({
      data: session
    });

    // Set HTTP-only cookie
    const cookie = serialize('auth-token', sessionToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 24 * 60 * 60,
      path: '/'
    });

    // Audit session creation
    await this.auditService.log({
      action: 'SESSION_CREATED',
      userId: user.id,
      sessionId: session.id,
      metadata: {
        userAgent: request.headers.get('user-agent'),
        ipAddress: request.ip,
        cookieSet: true
      }
    });

    return {
      ...session,
      cookie
    };
  }

  async validateSession(sessionToken: string): Promise<Session | null> {
    try {
      // Verify JWT token
      const decoded = await this.jwtService.verify(sessionToken);
      
      // Get session from Redis
      const sessionData = await this.redis.get(`session:${decoded.sessionId}`);
      
      if (!sessionData) {
        // Check database as fallback
        const session = await this.prisma.session.findUnique({
          where: { id: decoded.sessionId }
        });
        
        if (!session || !session.isActive) {
          return null;
        }
        
        // Restore session in Redis
        await this.redis.setex(
          `session:${session.id}`,
          Math.floor((session.expiresAt.getTime() - Date.now()) / 1000),
          JSON.stringify(session)
        );
        
        return session;
      }
      
      const session = JSON.parse(sessionData);
      
      // Check if session is expired
      if (new Date(session.expiresAt) < new Date()) {
        await this.invalidateSession(session.id);
        return null;
      }
      
      // Update last active time
      session.lastActiveAt = new Date();
      await this.redis.setex(
        `session:${session.id}`,
        Math.floor((session.expiresAt.getTime() - Date.now()) / 1000),
        JSON.stringify(session)
      );
      
      return session;
    } catch (error) {
      return null;
    }
  }

  async invalidateSession(sessionId: string): Promise<void> {
    // Remove from Redis
    await this.redis.del(`session:${sessionId}`);
    
    // Update database
    await this.prisma.session.update({
      where: { id: sessionId },
      data: {
        isActive: false,
        updatedAt: new Date()
      }
    });
    
    // Audit session invalidation
    await this.auditService.log({
      action: 'SESSION_INVALIDATED',
      sessionId: sessionId,
      metadata: {
        reason: 'Session invalidated',
        timestamp: new Date().toISOString()
      }
    });
  }

  async invalidateAllUserSessions(userId: string): Promise<void> {
    // Get all user sessions
    const sessions = await this.prisma.session.findMany({
      where: { userId, isActive: true }
    });
    
    // Invalidate all sessions
    for (const session of sessions) {
      await this.invalidateSession(session.id);
    }
  }

  async getSessionActivity(userId: string): Promise<SessionActivity[]> {
    const sessions = await this.prisma.session.findMany({
      where: { userId },
      orderBy: { lastActiveAt: 'desc' },
      take: 10
    });
    
    return sessions.map(session => ({
      id: session.id,
      createdAt: session.createdAt,
      lastActiveAt: session.lastActiveAt,
      ipAddress: session.ipAddress,
      userAgent: session.userAgent,
      isActive: session.isActive
    }));
  }
}
```

**Session Security Controls:**
```typescript
// Session Security Controls
export class SessionSecurityControls {
  private sessionManager: SessionManager;
  private auditService: AuditService;
  private alertService: AlertService;

  async detectSessionHijacking(session: Session, request: NextRequest): Promise<boolean> {
    // Check for suspicious activity
    const suspiciousActivity = await this.analyzeSessionActivity(session, request);
    
    if (suspiciousActivity.isSuspicious) {
      // Log security incident
      await this.auditService.log({
        action: 'SESSION_HIJACKING_DETECTED',
        userId: session.userId,
        sessionId: session.id,
        metadata: {
          suspiciousActivity,
          currentRequest: {
            ipAddress: request.ip,
            userAgent: request.headers.get('user-agent')
          },
          originalSession: {
            ipAddress: session.ipAddress,
            userAgent: session.userAgent
          }
        }
      });

      // Send security alert
      await this.alertService.sendAlert({
        type: 'SESSION_HIJACKING',
        severity: 'HIGH',
        userId: session.userId,
        sessionId: session.id,
        message: 'Potential session hijacking detected',
        details: suspiciousActivity
      });

      // Invalidate session
      await this.sessionManager.invalidateSession(session.id);
      
      return true;
    }
    
    return false;
  }

  private async analyzeSessionActivity(session: Session, request: NextRequest): Promise<{
    isSuspicious: boolean;
    reasons: string[];
    riskScore: number;
  }> {
    const reasons: string[] = [];
    let riskScore = 0;

    // Check IP address change
    if (session.ipAddress !== request.ip) {
      reasons.push('IP address changed');
      riskScore += 30;
    }

    // Check user agent change
    if (session.userAgent !== request.headers.get('user-agent')) {
      reasons.push('User agent changed');
      riskScore += 20;
    }

    // Check geographic location (if available)
    const geoInfo = await this.getGeoInfo(request.ip);
    const originalGeoInfo = await this.getGeoInfo(session.ipAddress);
    
    if (geoInfo.country !== originalGeoInfo.country) {
      reasons.push('Geographic location changed');
      riskScore += 40;
    }

    // Check time since last activity
    const timeSinceLastActivity = Date.now() - session.lastActiveAt.getTime();
    if (timeSinceLastActivity > 24 * 60 * 60 * 1000) { // 24 hours
      reasons.push('Long period of inactivity');
      riskScore += 10;
    }

    return {
      isSuspicious: riskScore > 50,
      reasons,
      riskScore
    };
  }

  private async getGeoInfo(ipAddress: string): Promise<{
    country: string;
    city: string;
  }> {
    // Implement geolocation lookup
    // This is a simplified example
    return {
      country: 'US',
      city: 'Unknown'
    };
  }
}
```

**Security Controls:**
- **Storage**: HTTP-only cookies with secure flags
- **Management**: Secure session creation, validation, and invalidation
- **Monitoring**: Session activity monitoring and anomaly detection
- **Hijacking Protection**: Session hijacking detection and prevention
- **Timeout**: Configurable session timeout and renewal
- **Audit**: Comprehensive session audit logging

### üèóÔ∏è Security Infrastructure

#### Deployment Architecture
```yaml
# Security Infrastructure Deployment
security:
  zones:
    - name: "Public Zone"
      components:
        - "Load Balancer"
        - "WAF (Web Application Firewall)"
        - "CDN"
      security_controls:
        - "DDoS Protection"
        - "SSL/TLS Termination"
        - "Rate Limiting"
        - "Security Headers"
    
    - name: "Application Zone"
      components:
        - "Next.js Application"
        - "API Gateway"
        - "Authentication Service"
      security_controls:
        - "Application Authentication"
        - "API Security"
        - "Session Management"
        - "Input Validation"
    
    - name: "Data Zone"
      components:
        - "Database (SQLite)"
        - "Redis Cache"
        - "File Storage"
      security_controls:
        - "Database Encryption"
        - "Access Control"
        - "Audit Logging"
        - "Backup & Recovery"
    
    - name: "Management Zone"
      components:
        - "Security Monitoring"
        - "Log Management"
        - "Alert System"
        - "Admin Interface"
      security_controls:
        - "Security Monitoring"
        - "Log Aggregation"
        - "Alert Management"
        - "Admin Access Control"
```

**Security Monitoring:**
```typescript
// Security Monitoring Service
export class SecurityMonitoringService {
  private logService: LogService;
  private alertService: AlertService;
  private metricsService: MetricsService;

  async monitorSecurityEvents(): Promise<void> {
    // Monitor authentication events
    this.monitorAuthenticationEvents();
    
    // Monitor authorization events
    this.monitorAuthorizationEvents();
    
    // Monitor session events
    this.monitorSessionEvents();
    
    // Monitor database events
    this.monitorDatabaseEvents();
    
    // Monitor API events
    this.monitorAPIEvents();
  }

  private monitorAuthenticationEvents(): void {
    // Monitor for authentication failures
    this.logService.on('AUTHENTICATION_FAILED', async (event) => {
      const failureCount = await this.getRecentAuthFailures(event.userId);
      
      if (failureCount > 5) { // Threshold for brute force detection
        await this.alertService.sendAlert({
          type: 'BRUTE_FORCE_ATTACK',
          severity: 'HIGH',
          userId: event.userId,
          message: 'Potential brute force attack detected',
          details: {
            failureCount,
            timeWindow: '5 minutes',
            ipAddress: event.ipAddress
          }
        });
      }
    });
  }

  private monitorAuthorizationEvents(): void {
    // Monitor for authorization failures
    this.logService.on('AUTHORIZATION_FAILED', async (event) => {
      const failureCount = await this.getRecentAuthzFailures(event.userId);
      
      if (failureCount > 10) { // Threshold for suspicious activity
        await this.alertService.sendAlert({
          type: 'SUSPICIOUS_ACTIVITY',
          severity: 'MEDIUM',
          userId: event.userId,
          message: 'Suspicious authorization activity detected',
          details: {
            failureCount,
            timeWindow: '10 minutes',
            attemptedPermissions: event.metadata?.attemptedPermissions
          }
        });
      }
    });
  }

  private monitorSessionEvents(): void {
    // Monitor for session events
    this.logService.on('SESSION_HIJACKING_DETECTED', async (event) => {
      await this.alertService.sendAlert({
        type: 'SESSION_HIJACKING',
        severity: 'CRITICAL',
        userId: event.userId,
        sessionId: event.sessionId,
        message: 'Session hijacking detected',
        details: event.metadata
      });
    });
  }

  private monitorDatabaseEvents(): void {
    // Monitor for database security events
    this.logService.on('DATABASE_ACCESS_DENIED', async (event) => {
      await this.alertService.sendAlert({
        type: 'DATABASE_SECURITY',
        severity: 'HIGH',
        message: 'Database access denied',
        details: event.metadata
      });
    });
  }

  private monitorAPIEvents(): void {
    // Monitor for API security events
    this.logService.on('API_RATE_LIMIT_EXCEEDED', async (event) => {
      await this.alertService.sendAlert({
        type: 'API_SECURITY',
        severity: 'MEDIUM',
        message: 'API rate limit exceeded',
        details: event.metadata
      });
    });
  }

  private async getRecentAuthFailures(userId: string): Promise<number> {
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    
    const count = await this.prisma.auditLog.count({
      where: {
        userId,
        action: 'AUTHENTICATION_FAILED',
        createdAt: {
          gte: fiveMinutesAgo
        }
      }
    });
    
    return count;
  }

  private async getRecentAuthzFailures(userId: string): Promise<number> {
    const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
    
    const count = await this.prisma.auditLog.count({
      where: {
        userId,
        action: 'AUTHORIZATION_FAILED',
        createdAt: {
          gte: tenMinutesAgo
        }
      }
    });
    
    return count;
  }
}
```

**Security Controls:**
- **Zones**: Security zones with appropriate controls
- **Monitoring**: Comprehensive security event monitoring
- **Alerting**: Real-time security alerting and response
- **Logging**: Centralized security logging and analysis
- **Metrics**: Security metrics and performance monitoring

### üìä Security Compliance

#### Compliance Framework Implementation
```typescript
// Compliance Framework Service
export class ComplianceService {
  private auditService: AuditService;
  private documentService: DocumentService;

  async assessCompliance(): Promise<ComplianceAssessment> {
    const frameworks = ['SOC2', 'GDPR', 'HIPAA'];
    const assessments: ComplianceFrameworkAssessment[] = [];

    for (const framework of frameworks) {
      const assessment = await this.assessFramework(framework);
      assessments.push(assessment);
    }

    return {
      overallScore: this.calculateOverallScore(assessments),
      frameworks: assessments,
      recommendations: this.generateRecommendations(assessments),
      lastAssessed: new Date()
    };
  }

  private async assessFramework(framework: string): Promise<ComplianceFrameworkAssessment> {
    const requirements = await this.getFrameworkRequirements(framework);
    const assessments: ComplianceRequirementAssessment[] = [];

    for (const requirement of requirements) {
      const assessment = await this.assessRequirement(framework, requirement);
      assessments.push(assessment);
    }

    return {
      framework,
      score: this.calculateFrameworkScore(assessments),
      requirements: assessments,
      status: this.determineFrameworkStatus(assessments)
    };
  }

  private async assessFrameworkRequirements(framework: string): Promise<ComplianceRequirement[]> {
    switch (framework) {
      case 'SOC2':
        return this.getSOC2Requirements();
      case 'GDPR':
        return this.getGDPRRequirements();
      case 'HIPAA':
        return this.getHIPAARequirements();
      default:
        return [];
    }
  }

  private getSOC2Requirements(): ComplianceRequirement[] {
    return [
      {
        id: 'SOC2-CC1',
        name: 'Control Environment',
        description: 'Control environment demonstrates commitment to integrity and ethical values',
        category: 'Governance',
        assessment: 'Evaluate management tone, policies, and procedures'
      },
      {
        id: 'SOC2-CC2',
        name: 'Communication',
        description: 'Board of directors communicates with management about internal control',
        category: 'Communication',
        assessment: 'Review board meeting minutes and communications'
      },
      {
        id: 'SOC2-CC3',
        name: 'Risk Assessment',
        description: 'Organization identifies risks that could prevent objectives from being achieved',
        category: 'Risk Management',
        assessment: 'Review risk assessment process and documentation'
      },
      {
        id: 'SOC2-CC4',
        name: 'Monitoring Activities',
        description: 'Organization selects, develops, and performs monitoring activities',
        category: 'Monitoring',
        assessment: 'Evaluate monitoring procedures and frequency'
      },
      {
        id: 'SOC2-CC5',
        name: 'Control Activities',
        description: 'Control activities are established through policies and procedures',
        category: 'Control Activities',
        assessment: 'Review control activities and implementation'
      }
    ];
  }

  private getGDPRRequirements(): ComplianceRequirement[] {
    return [
      {
        id: 'GDPR-ART5',
        name: 'Lawfulness, Fairness, and Transparency',
        description: 'Personal data processed lawfully, fairly, and transparently',
        category: 'Data Protection Principles',
        assessment: 'Review data processing policies and procedures'
      },
      {
        id: 'GDPR-ART6',
        name: 'Lawfulness of Processing',
        description: 'Processing has lawful basis under GDPR',
        category: 'Legal Basis',
        assessment: 'Verify lawful basis for all data processing'
      },
      {
        id: 'GDPR-ART7',
        name: 'Conditions for Consent',
        description: 'Consent must be freely given, specific, informed, and unambiguous',
        category: 'Consent',
        assessment: 'Review consent mechanisms and documentation'
      },
      {
        id: 'GDPR-ART13',
        name: 'Information to be Provided',
        description: 'Data subjects provided with information about processing',
        category: 'Transparency',
        assessment: 'Review privacy notices and information provided'
      },
      {
        id: 'GDPR-ART15',
        name: 'Right of Access',
        description: 'Data subjects have right to access their personal data',
        category: 'Data Subject Rights',
        assessment: 'Verify data access request procedures'
      }
    ];
  }

  private getHIPAARequirements(): ComplianceRequirement[] {
    return [
      {
        id: 'HIPAA-164.312',
        name: 'Technical Safeguards',
        description: 'Implement technical policies and procedures for PHI protection',
        category: 'Technical Safeguards',
        assessment: 'Review technical security measures'
      },
      {
        id: 'HIPAA-164.312(a)(1)',
        name: 'Access Control',
        description: 'Implement technical policies and procedures for electronic PHI access',
        category: 'Access Control',
        assessment: 'Evaluate access control mechanisms'
      },
      {
        id: 'HIPAA-164.312(a)(2)(i)',
        name: 'Unique User Identification',
        description: 'Assign unique name and/or number for tracking user identity',
        category: 'User Identification',
        assessment: 'Review user identification procedures'
      },
      {
        id: 'HIPAA-164.312(a)(2)(ii)',
        name: 'Emergency Access Procedure',
        description: 'Establish emergency access procedures',
        category: 'Emergency Access',
        assessment: 'Review emergency access procedures'
      },
      {
        id: 'HIPAA-164.312(e)(1)',
        name: 'Encryption',
        description: 'Implement encryption mechanisms for PHI',
        category: 'Encryption',
        assessment: 'Review encryption implementation'
      }
    ];
  }

  private async assessRequirement(
    framework: string,
    requirement: ComplianceRequirement
  ): Promise<ComplianceRequirementAssessment> {
    // Implement requirement assessment logic
    const evidence = await this.collectEvidence(framework, requirement.id);
    const score = this.calculateRequirementScore(evidence);
    const status = this.determineRequirementStatus(score);

    return {
      requirement,
      score,
      status,
      evidence,
      lastAssessed: new Date()
    };
  }

  private async collectEvidence(framework: string, requirementId: string): Promise<ComplianceEvidence[]> {
    // Collect evidence for compliance assessment
    return [
      {
        type: 'Policy',
        description: 'Security policy documentation',
        url: '/docs/security-policies',
        valid: true
      },
      {
        type: 'Procedure',
        description: 'Security implementation procedures',
        url: '/docs/security-procedures',
        valid: true
      },
      {
        type: 'Technical',
        description: 'Technical implementation evidence',
        url: '/docs/technical-evidence',
        valid: true
      },
      {
        type: 'Audit',
        description: 'Audit trail and logs',
        url: '/docs/audit-evidence',
        valid: true
      }
    ];
  }

  private calculateRequirementScore(evidence: ComplianceEvidence[]): number {
    const validEvidence = evidence.filter(e => e.valid).length;
    return (validEvidence / evidence.length) * 100;
  }

  private determineRequirementStatus(score: number): ComplianceStatus {
    if (score >= 90) return 'COMPLIANT';
    if (score >= 70) return 'PARTIALLY_COMPLIANT';
    return 'NON_COMPLIANT';
  }

  private calculateFrameworkScore(assessments: ComplianceRequirementAssessment[]): number {
    const totalScore = assessments.reduce((sum, assessment) => sum + assessment.score, 0);
    return totalScore / assessments.length;
  }

  private determineFrameworkStatus(assessments: ComplianceRequirementAssessment[]): ComplianceStatus {
    const nonCompliantCount = assessments.filter(a => a.status === 'NON_COMPLIANT').length;
    
    if (nonCompliantCount === 0) return 'COMPLIANT';
    if (nonCompliantCount <= assessments.length * 0.1) return 'PARTIALLY_COMPLIANT';
    return 'NON_COMPLIANT';
  }

  private calculateOverallScore(assessments: ComplianceFrameworkAssessment[]): number {
    const totalScore = assessments.reduce((sum, assessment) => sum + assessment.score, 0);
    return totalScore / assessments.length;
  }

  private generateRecommendations(assessments: ComplianceFrameworkAssessment[]): ComplianceRecommendation[] {
    const recommendations: ComplianceRecommendation[] = [];

    assessments.forEach(assessment => {
      assessment.requirements.forEach(req => {
        if (req.status === 'NON_COMPLIANT') {
          recommendations.push({
            framework: assessment.framework,
            requirement: req.requirement.id,
            priority: 'HIGH',
            recommendation: `Implement controls to meet ${req.requirement.name} requirement`,
            estimatedEffort: 'Medium',
            deadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
          });
        } else if (req.status === 'PARTIALLY_COMPLIANT') {
          recommendations.push({
            framework: assessment.framework,
            requirement: req.requirement.id,
            priority: 'MEDIUM',
            recommendation: `Enhance controls for ${req.requirement.name} requirement`,
            estimatedEffort: 'Low',
            deadline: new Date(Date.now() + 60 * 24 * 60 * 60 * 1000) // 60 days
          });
        }
      });
    });

    return recommendations;
  }
}
```

**Security Controls:**
- **Compliance**: Automated compliance assessment and reporting
- **Evidence**: Comprehensive evidence collection and management
- **Monitoring**: Continuous compliance monitoring
- **Reporting**: Compliance reporting and documentation
- **Remediation**: Compliance gap remediation tracking

### üéØ Implementation Strategy

#### Phased Implementation Approach
```yaml
implementation_phases:
  phase_1:
    name: "Security Foundation"
    duration: "2 weeks"
    components:
      - "NextAuth.js Implementation"
      - "Secure Session Management"
      - "Password Hashing"
      - "Security Headers"
    success_criteria:
      - "Authentication system operational"
      - "Session security implemented"
      - "Password security enhanced"
      - "Security headers deployed"

  phase_2:
    name: "Database Architecture"
    duration: "1 week"
    components:
      - "TPRM Schema Design"
      - "Prisma Migrations"
      - "Relationship Implementation"
      - "Audit Logging"
    success_criteria:
      - "Database schema complete"
      - "Data relationships established"
      - "Audit logging operational"
      - "Data security implemented"

  phase_3:
    name: "Authorization System"
    duration: "1 week"
    components:
      - "Server-side RBAC"
      - "Permission Management"
      - "Authorization Components"
      - "Security Testing"
    success_criteria:
      - "RBAC system operational"
      - "Permission management functional"
      - "Authorization components complete"
      - "Security testing passed"

  phase_4:
    name: "Admin System"
    duration: "1 week"
    components:
      - "Admin Dashboard"
      - "User Management"
      - "Role Management"
      - "System Monitoring"
    success_criteria:
      - "Admin dashboard functional"
      - "User management operational"
      - "Role management complete"
      - "System monitoring active"

  phase_5:
    name: "Development Infrastructure"
    duration: "1 week"
    components:
      - "CI/CD Pipeline"
      - "Git Workflow"
      - "Team Training"
      - "Documentation"
    success_criteria:
      - "CI/CD pipeline operational"
      - "Git workflow established"
      - "Team training completed"
      - "Documentation complete"
```

#### Migration Strategy
```typescript
// Migration Strategy Service
export class MigrationStrategyService {
  private auditService: AuditService;
  private backupService: BackupService;

  async planMigration(): Promise<MigrationPlan> {
    return {
      phases: [
        {
          name: 'Pre-Migration Assessment',
          duration: '1 day',
          tasks: [
            'Assess current system state',
            'Identify migration risks',
            'Create backup strategy',
            'Prepare rollback plan'
          ],
          successCriteria: [
            'Risk assessment complete',
            'Backup strategy validated',
            'Rollback plan tested'
          ]
        },
        {
          name: 'Security Foundation Migration',
          duration: '2 days',
          tasks: [
            'Deploy NextAuth.js',
            'Migrate user accounts',
            'Implement secure sessions',
            'Remove localStorage auth'
          ],
          successCriteria: [
            'New authentication system operational',
            'User accounts migrated successfully',
            'Old authentication system removed'
          ]
        },
        {
          name: 'Data Migration',
          duration: '1 day',
          tasks: [
            'Migrate database schema',
            'Transfer existing data',
            'Validate data integrity',
            'Test data access'
          ],
          successCriteria: [
            'Database schema migrated',
            'Data integrity validated',
            'Access controls functional'
          ]
        },
        {
          name: 'Feature Migration',
          duration: '2 days',
          tasks: [
            'Migrate core features',
            'Update UI components',
            'Test functionality',
            'Validate user experience'
          ],
          successCriteria: [
            'All features migrated',
            'UI components updated',
            'Functionality validated'
          ]
        },
        {
          name: 'Post-Migration Validation',
          duration: '1 day',
          tasks: [
            'Comprehensive testing',
            'Security validation',
            'Performance testing',
            'User acceptance testing'
          ],
          successCriteria: [
            'All tests passed',
            'Security controls validated',
            'Performance requirements met',
            'User acceptance confirmed'
          ]
        }
      ],
      rollbackStrategy: {
        triggers: [
          'Critical security vulnerabilities',
          'Data corruption detected',
          'Performance degradation > 50%',
          'User functionality broken'
        ],
        procedure: 'Restore from backup, revert to previous system',
        timeline: '4 hours from detection'
      }
    };
  }

  async executeMigration(migrationPlan: MigrationPlan): Promise<MigrationResult> {
    const result: MigrationResult = {
      success: false,
      phases: [],
      errors: [],
      startTime: new Date(),
      endTime: null
    };

    try {
      // Create backup before migration
      await this.backupService.createBackup();

      // Execute migration phases
      for (const phase of migrationPlan.phases) {
        const phaseResult = await this.executeMigrationPhase(phase);
        result.phases.push(phaseResult);

        if (!phaseResult.success) {
          throw new Error(`Migration phase '${phase.name}' failed`);
        }
      }

      result.success = true;
      result.endTime = new Date();

      // Audit migration completion
      await this.auditService.log({
        action: 'MIGRATION_COMPLETED',
        metadata: {
          duration: result.endTime.getTime() - result.startTime.getTime(),
          phases: result.phases.length,
          success: result.success
        }
      });

    } catch (error) {
      result.errors.push(error.message);
      result.endTime = new Date();

      // Trigger rollback if needed
      await this.triggerRollback(error);

      // Audit migration failure
      await this.auditService.log({
        action: 'MIGRATION_FAILED',
        metadata: {
          error: error.message,
          phases: result.phases.length,
          duration: result.endTime.getTime() - result.startTime.getTime()
        }
      });
    }

    return result;
  }

  private async executeMigrationPhase(phase: MigrationPhase): Promise<MigrationPhaseResult> {
    const result: MigrationPhaseResult = {
      name: phase.name,
      success: false,
      tasks: [],
      errors: [],
      startTime: new Date(),
      endTime: null
    };

    try {
      // Execute phase tasks
      for (const task of phase.tasks) {
        const taskResult = await this.executeMigrationTask(task);
        result.tasks.push(taskResult);

        if (!taskResult.success) {
          throw new Error(`Migration task '${task}' failed`);
        }
      }

      // Validate phase success criteria
      const validationResults = await this.validatePhaseSuccess(phase);
      
      if (!validationResults.allPassed) {
        throw new Error(`Phase success criteria not met: ${validationResults.failedCriteria.join(', ')}`);
      }

      result.success = true;
      result.endTime = new Date();

    } catch (error) {
      result.errors.push(error.message);
      result.endTime = new Date();
    }

    return result;
  }

  private async executeMigrationTask(task: string): Promise<MigrationTaskResult> {
    const result: MigrationTaskResult = {
      task,
      success: false,
      error: null,
      startTime: new Date(),
      endTime: null
    };

    try {
      // Execute specific migration task
      switch (task) {
        case 'Deploy NextAuth.js':
          await this.deployNextAuth();
          break;
        case 'Migrate user accounts':
          await this.migrateUserAccounts();
          break;
        case 'Implement secure sessions':
          await this.implementSecureSessions();
          break;
        case 'Remove localStorage auth':
          await this.removeLocalStorageAuth();
          break;
        default:
          throw new Error(`Unknown migration task: ${task}`);
      }

      result.success = true;
      result.endTime = new Date();

    } catch (error) {
      result.error = error.message;
      result.endTime = new Date();
    }

    return result;
  }

  private async validatePhaseSuccess(phase: MigrationPhase): Promise<PhaseValidationResult> {
    const validationResults: boolean[] = [];

    for (const criterion of phase.successCriteria) {
      const result = await this.validateSuccessCriterion(criterion);
      validationResults.push(result);
    }

    return {
      allPassed: validationResults.every(r => r),
      passedCriteria: phase.successCriteria.filter((_, i) => validationResults[i]),
      failedCriteria: phase.successCriteria.filter((_, i) => !validationResults[i])
    };
  }

  private async validateSuccessCriterion(criterion: string): Promise<boolean> {
    // Implement validation logic for each success criterion
    switch (criterion) {
      case 'New authentication system operational':
        return await this.validateAuthenticationSystem();
      case 'User accounts migrated successfully':
        return await this.validateUserMigration();
      case 'Old authentication system removed':
        return await this.validateOldAuthRemoval();
      default:
        return true; // Default to true for unknown criteria
    }
  }

  private async triggerRollback(error: Error): Promise<void> {
    // Implement rollback logic
    await this.auditService.log({
      action: 'ROLLBACK_TRIGGERED',
      metadata: {
        error: error.message,
        timestamp: new Date().toISOString()
      }
    });

    // Execute rollback procedures
    await this.backupService.restoreBackup();
  }

  // Migration task implementations
  private async deployNextAuth(): Promise<void> {
    // Implement NextAuth.js deployment
    // This would involve package installation, configuration, and testing
  }

  private async migrateUserAccounts(): Promise<void> {
    // Implement user account migration
    // This would involve data migration, password hashing, and validation
  }

  private async implementSecureSessions(): Promise<void> {
    // Implement secure session management
    // This would involve session configuration, cookie setup, and validation
  }

  private async removeLocalStorageAuth(): Promise<void> {
    // Remove localStorage authentication
    // This would involve code cleanup and validation
  }

  // Validation implementations
  private async validateAuthenticationSystem(): Promise<boolean> {
    // Validate that new authentication system is operational
    return true; // Placeholder
  }

  private async validateUserMigration(): Promise<boolean> {
    // Validate that user accounts were migrated successfully
    return true; // Placeholder
  }

  private async validateOldAuthRemoval(): Promise<boolean> {
    // Validate that old authentication system was removed
    return true; // Placeholder
  }
}
```

**Security Controls:**
- **Migration**: Secure migration strategy with rollback
- **Validation**: Comprehensive validation of migration success
- **Backup**: Secure backup and recovery procedures
- **Monitoring**: Migration monitoring and alerting
- **Testing**: Thorough testing of migrated components

### üîß Technical Specifications

#### Technology Stack Security
```yaml
technology_stack:
  framework:
    name: "Next.js 15"
    version: "15.0.0"
    security_features:
      - "Built-in CSRF protection"
      - "Security headers"
      - "Input validation"
      - "XSS protection"
  
  language:
    name: "TypeScript 5"
    version: "5.0.0"
    security_features:
      - "Type safety"
      - "Null safety"
      - "Static analysis"
      - "Security constraints"
  
  orm:
    name: "Prisma"
    version: "5.0.0"
    security_features:
      - "SQL injection prevention"
      - "Data validation"
      - "Type safety"
      - "Query optimization"
  
  authentication:
    name: "NextAuth.js"
    version: "4.24.0"
    security_features:
      - "JWT sessions"
      - "Secure cookies"
      - "Password hashing"
      - "Multi-factor support"
  
  database:
    name: "SQLite"
    version: "3.43.0"
    security_features:
      - "File encryption"
      - "Access controls"
      - "Backup support"
      - "Transaction safety"
  
  ui:
    name: "shadcn/ui"
    version: "0.7.0"
    security_features:
      - "Component security"
      - "Input validation"
      - "Accessibility"
      - "Theme security"
  
  styling:
    name: "Tailwind CSS 4"
    version: "4.0.0"
    security_features:
      - "CSS purification"
      - "Content Security Policy"
      - "Style isolation"
      - "Theme security"
```

#### Security Patterns
```typescript
// Security Patterns Implementation
export class SecurityPatterns {
  // Singleton Pattern for Security Services
  private static instance: SecurityPatterns;
  private authService: AuthenticationService;
  private authorizationService: AuthorizationService;
  private auditService: AuditService;

  static getInstance(): SecurityPatterns {
    if (!SecurityPatterns.instance) {
      SecurityPatterns.instance = new SecurityPatterns();
    }
    return SecurityPatterns.instance;
  }

  // Factory Pattern for Security Components
  createSecurityComponent(type: SecurityComponentType): SecurityComponent {
    switch (type) {
      case 'AUTHENTICATION':
        return new AuthenticationComponent();
      case 'AUTHORIZATION':
        return new AuthorizationComponent();
      case 'SESSION':
        return new SessionComponent();
      case 'AUDIT':
        return new AuditComponent();
      default:
        throw new Error(`Unknown security component type: ${type}`);
    }
  }

  // Observer Pattern for Security Events
  private securityEventObservers: SecurityEventObserver[] = [];

  addSecurityEventObserver(observer: SecurityEventObserver): void {
    this.securityEventObservers.push(observer);
  }

  removeSecurityEventObserver(observer: SecurityEventObserver): void {
    const index = this.securityEventObservers.indexOf(observer);
    if (index > -1) {
      this.securityEventObservers.splice(index, 1);
    }
  }

  notifySecurityEventObservers(event: SecurityEvent): void {
    this.securityEventObservers.forEach(observer => {
      observer.onSecurityEvent(event);
    });
  }

  // Strategy Pattern for Authentication
  private authenticationStrategies: Map<string, AuthenticationStrategy> = new Map();

  addAuthenticationStrategy(name: string, strategy: AuthenticationStrategy): void {
    this.authenticationStrategies.set(name, strategy);
  }

  getAuthenticationStrategy(name: string): AuthenticationStrategy {
    const strategy = this.authenticationStrategies.get(name);
    if (!strategy) {
      throw new Error(`Authentication strategy not found: ${name}`);
    }
    return strategy;
  }

  // Decorator Pattern for Security Middleware
  createSecurityMiddleware(baseMiddleware: Middleware): SecurityMiddleware {
    return new SecurityMiddleware(baseMiddleware);
  }
}

// Security Component Interface
interface SecurityComponent {
  initialize(): Promise<void>;
  execute(request: any): Promise<any>;
  validate(result: any): Promise<boolean>;
  cleanup(): Promise<void>;
}

// Security Event Observer Interface
interface SecurityEventObserver {
  onSecurityEvent(event: SecurityEvent): void;
}

// Authentication Strategy Interface
interface AuthenticationStrategy {
  authenticate(credentials: any): Promise<AuthenticationResult>;
  validate(token: string): Promise<boolean>;
  refresh(token: string): Promise<string>;
  revoke(token: string): Promise<void>;
}

// Security Middleware Class
class SecurityMiddleware implements Middleware {
  private baseMiddleware: Middleware;
  private securityServices: SecurityServices;

  constructor(baseMiddleware: Middleware) {
    this.baseMiddleware = baseMiddleware;
    this.securityServices = new SecurityServices();
  }

  async use(request: any, response: any, next: Function): Promise<void> {
    // Apply security checks
    await this.securityServices.validateRequest(request);
    
    // Execute base middleware
    await this.baseMiddleware.use(request, response, next);
    
    // Apply security response headers
    await this.securityServices.secureResponse(response);
  }
}
```

#### Performance Considerations
```typescript
// Security Performance Optimization
export class SecurityPerformanceOptimizer {
  private cacheService: CacheService;
  private metricsService: MetricsService;

  async optimizeSecurityOperations(): Promise<void> {
    // Optimize authentication performance
    await this.optimizeAuthentication();
    
    // Optimize authorization performance
    await this.optimizeAuthorization();
    
    // Optimize session management performance
    await this.optimizeSessionManagement();
    
    // Optimize audit logging performance
    await this.optimizeAuditLogging();
  }

  private async optimizeAuthentication(): Promise<void> {
    // Cache authentication results
    this.cacheService.setCacheStrategy('auth', {
      ttl: 300, // 5 minutes
      maxSize: 1000
    });

    // Implement connection pooling for database queries
    this.optimizeDatabaseConnections();

    // Use efficient password hashing with reasonable rounds
    this.configurePasswordHashing();
  }

  private async optimizeAuthorization(): Promise<void> {
    // Cache permission checks
    this.cacheService.setCacheStrategy('permissions', {
      ttl: 600, // 10 minutes
      maxSize: 5000
    });

    // Pre-load frequently accessed permissions
    await this.preloadPermissions();

    // Use efficient permission validation algorithms
    this.optimizePermissionValidation();
  }

  private async optimizeSessionManagement(): Promise<void> {
    // Use Redis for fast session storage
    this.configureRedisSessionStorage();

    // Implement session token validation caching
    this.cacheService.setCacheStrategy('session-validation', {
      ttl: 60, // 1 minute
      maxSize: 10000
    });

    // Optimize session cleanup processes
    this.configureSessionCleanup();
  }

  private async optimizeAuditLogging(): Promise<void> {
    // Implement batch audit logging
    this.configureBatchAuditLogging();

    // Use efficient log storage and retrieval
    this.optimizeLogStorage();

    // Implement log archiving and cleanup
    this.configureLogManagement();
  }

  private optimizeDatabaseConnections(): void {
    // Configure connection pooling
    const poolConfig = {
      min: 2,
      max: 10,
      idleTimeoutMillis: 30000,
      acquireTimeoutMillis: 10000
    };

    // Use prepared statements for frequently executed queries
    this.configurePreparedStatements();
  }

  private configurePasswordHashing(): void {
    // Use bcrypt with optimal rounds (12-14)
    const bcryptRounds = process.env.NODE_ENV === 'production' ? 12 : 10;
    
    // Implement password strength validation
    this.configurePasswordValidation();
  }

  private async preloadPermissions(): Promise<void> {
    // Pre-load role permissions
    const roles = await this.prisma.role.findMany({
      include: {
        permissions: true
      }
    });

    // Cache role permissions
    for (const role of roles) {
      this.cacheService.set(`role:${role.name}:permissions`, role.permissions);
    }
  }

  private optimizePermissionValidation(): void {
    // Use efficient permission checking algorithms
    // Implement early termination for wildcard permissions
    // Cache permission validation results
  }

  private configureRedisSessionStorage(): void {
    // Configure Redis for session storage
    const redisConfig = {
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || '0')
    };

    // Implement session compression
    this.configureSessionCompression();
  }

  private configureSessionCompression(): void {
    // Compress session data before storage
    // Use efficient serialization formats
  }

  private configureSessionCleanup(): void {
    // Implement automated session cleanup
    // Use efficient cleanup algorithms
  }

  private configureBatchAuditLogging(): void {
    // Buffer audit events and log in batches
    // Implement async logging with error handling
  }

  private optimizeLogStorage(): void {
    // Use efficient log storage formats
    // Implement log indexing for fast retrieval
  }

  private configureLogManagement(): void {
    // Implement automated log archiving
    // Configure log retention policies
  }

  private configurePreparedStatements(): void {
    // Use prepared statements for database queries
    // Cache frequently used query plans
  }

  private configurePasswordValidation(): void {
    // Implement comprehensive password validation
    // Use efficient validation algorithms
  }
}
```

**Security Controls:**
- **Performance**: Security performance optimization
- **Caching**: Strategic caching for security operations
- **Efficiency**: Efficient security algorithms and data structures
- **Monitoring**: Security performance monitoring and alerting
- **Scaling**: Security system scalability considerations

### üéØ Implementation Strategy

#### Phased Approach
```yaml
implementation_strategy:
  phases:
    phase_1:
      name: "Security Foundation"
      timeline: "Week 1-2"
      focus: "Authentication and session security"
      deliverables:
        - "NextAuth.js implementation"
        - "Secure session management"
        - "Password hashing system"
        - "Security headers deployment"
    
    phase_2:
      name: "Database Architecture"
      timeline: "Week 2-3"
      focus: "Database security and relationships"
      deliverables:
        - "TPRM schema design"
        - "Prisma migrations"
        - "Data encryption implementation"
        - "Audit logging system"
    
    phase_3:
      name: "Authorization System"
      timeline: "Week 3-4"
      focus: "RBAC and permission management"
      deliverables:
        - "Server-side RBAC implementation"
        - "Permission management interface"
        - "Authorization components"
        - "Security testing framework"
    
    phase_4:
      name: "Admin System"
      timeline: "Week 4-5"
      focus: "Administrative functionality"
      deliverables:
        - "Admin dashboard"
        - "User management system"
        - "Role management interface"
        - "System monitoring tools"
    
    phase_5:
      name: "Development Infrastructure"
      timeline: "Week 5-6"
      focus: "Development and deployment infrastructure"
      deliverables:
        - "CI/CD pipeline"
        - "Git workflow system"
        - "Team training materials"
        - "Project documentation"

  success_criteria:
    technical:
      - "Zero critical security vulnerabilities"
      - "100% authentication success rate"
      - "99.9% authorization accuracy"
      - "Complete audit trail coverage"
    
    business:
      - "100% compliance requirement achievement"
      - "50% reduction in security incidents"
      - "70% improvement in admin efficiency"
      - "Zero security-related downtime"
    
    process:
      - "100% security test pass rate"
      - "80% security code coverage"
      - "100% documentation completeness"
      - "90% reduction in implementation time"

  risk_mitigation:
    technical_risks:
      - "Authentication system failure"
      - "Data corruption during migration"
      - "Performance degradation"
      - "Compatibility issues"
    
    mitigation_strategies:
      - "Comprehensive testing and validation"
      - "Secure backup and rollback procedures"
      - "Performance monitoring and optimization"
      - "Compatibility testing and validation"
    
    contingency_plans:
      - "Immediate rollback capability"
      - "Alternative implementation approaches"
      - "Extended timeline if needed"
      - "Additional resource allocation"
```

#### Quality Assurance
```typescript
// Security Quality Assurance
export class SecurityQualityAssurance {
  private testingService: SecurityTestingService;
  private validationService: SecurityValidationService;
  private complianceService: ComplianceService;

  async performSecurityQA(): Promise<SecurityQAReport> {
    const report: SecurityQAReport = {
      timestamp: new Date(),
      tests: [],
      vulnerabilities: [],
    compliance: [],
      recommendations: [],
      overallScore: 0
    };

    // Execute security tests
    const testResults = await this.executeSecurityTests();
    report.tests = testResults;

    // Identify vulnerabilities
    const vulnerabilities = await this.identifyVulnerabilities();
    report.vulnerabilities = vulnerabilities;

    // Validate compliance
    const complianceResults = await this.validateCompliance();
    report.compliance = complianceResults;

    // Generate recommendations
    const recommendations = await this.generateRecommendations(testResults, vulnerabilities, complianceResults);
    report.recommendations = recommendations;

    // Calculate overall score
    report.overallScore = this.calculateOverallScore(testResults, vulnerabilities, complianceResults);

    return report;
  }

  private async executeSecurityTests(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Authentication Tests
    tests.push(...await this.testAuthentication());

    // Authorization Tests
    tests.push(...await this.testAuthorization());

    // Session Security Tests
    tests.push(...await this.testSessionSecurity());

    // Input Validation Tests
    tests.push(...await this.testInputValidation());

    // Output Encoding Tests
    tests.push(...await this.testOutputEncoding());

    // Database Security Tests
    tests.push(...await this.testDatabaseSecurity());

    // API Security Tests
    tests.push(...await this.testAPISecurity());

    // Compliance Tests
    tests.push(...await this.testCompliance());

    return tests;
  }

  private async testAuthentication(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test password hashing
    tests.push(await this.testPasswordHashing());

    // Test JWT validation
    tests.push(await this.testJWTValidation());

    // Test session management
    tests.push(await this.testSessionManagement());

    // Test authentication error handling
    tests.push(await this.testAuthenticationErrorHandling());

    return tests;
  }

  private async testAuthorization(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test role-based access control
    tests.push(await this.testRBAC());

    // Test permission validation
    tests.push(await this.testPermissionValidation());

    // Test authorization bypass prevention
    tests.push(await this.testAuthorizationBypassPrevention());

    // Test privilege escalation prevention
    tests.push(await this.testPrivilegeEscalationPrevention());

    return tests;
  }

  private async testSessionSecurity(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test session hijacking prevention
    tests.push(await this.testSessionHijackingPrevention());

    // Test session fixation prevention
    tests.push(await this.testSessionFixationPrevention());

    // Test session timeout enforcement
    tests.push(await this.testSessionTimeoutEnforcement());

    // Test concurrent session control
    tests.push(await this.testConcurrentSessionControl());

    return tests;
  }

  private async testInputValidation(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test SQL injection prevention
    tests.push(await this.testSQLInjectionPrevention());

    // Test XSS prevention
    tests.push(await this.testXSSPrevention());

    // Test CSRF prevention
    tests.push(await this.testCSRFPrevention());

    // Test input sanitization
    tests.push(await this.testInputSanitization());

    return tests;
  }

  private async testOutputEncoding(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test HTML encoding
    tests.push(await this.testHTMLEncoding());

    // Test JavaScript encoding
    tests.push(await this.testJavaScriptEncoding());

    // Test URL encoding
    tests.push(await this.testURLEncoding());

    // Test CSS encoding
    tests.push(await this.testCSSEncoding());

    return tests;
  }

  private async testDatabaseSecurity(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test data encryption
    tests.push(await this testDataEncryption());

    // Test access control
    tests.push(await this.testDatabaseAccessControl());

    // Test audit logging
    tests.push(await this.testAuditLogging());

    // Test data integrity
    tests.push(await this.testDataIntegrity());

    return tests;
  }

  private async testAPISecurity(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test API authentication
    tests.push(await this.testAPIAuthentication());

    // Test API authorization
    tests.push(await this.testAPIAuthorization());

    // Test rate limiting
    tests.push(await this.testRateLimiting());

    // Test API security headers
    tests.push(await this.testAPISecurityHeaders());

    return tests;
  }

  private async testCompliance(): Promise<SecurityTestResult[]> {
    const tests: SecurityTestResult[] = [];

    // Test SOC2 compliance
    tests.push(await this.testSOC2Compliance());

    // Test GDPR compliance
    tests.push(await this.testGDPRCompliance());

    // Test HIPAA compliance
    tests.push(await this.testHIPAACompliance());

    // Test data protection compliance
    tests.push(await this.testDataProtectionCompliance());

    return tests;
  }

  // Individual test implementations
  private async testPasswordHashing(): Promise<SecurityTestResult> {
    const result: SecurityTestResult = {
      name: 'Password Hashing',
      category: 'Authentication',
      status: 'PASSED',
      details: 'Password hashing implemented with bcrypt (12 rounds)',
      vulnerabilities: [],
      recommendations: []
    };

    try {
      // Test password hashing implementation
      const testPassword = 'TestPassword123!';
      const hash = await this.hashPassword(testPassword);
      
      // Verify hash is different from original
      if (hash === testPassword) {
        result.status = 'FAILED';
        result.vulnerabilities.push('Password not properly hashed');
        result.recommendations.push('Ensure bcrypt is properly configured');
      }

      // Verify hash can be verified
      const isValid = await this.verifyPassword(testPassword, hash);
      if (!isValid) {
        result.status = 'FAILED';
        result.vulnerabilities.push('Password verification failed');
        result.recommendations.push('Check bcrypt verification implementation');
      }

    } catch (error) {
      result.status = 'FAILED';
      result.vulnerabilities.push(`Password hashing test failed: ${error.message}`);
      result.recommendations.push('Review password hashing implementation');
    }

    return result;
  }

  private async testJWTValidation(): Promise<SecurityTestResult> {
    const result: SecurityTestResult = {
      name: 'JWT Validation',
      category: 'Authentication',
      status: 'PASSED',
      details: 'JWT validation implemented with proper signature verification',
      vulnerabilities: [],
      recommendations: []
    };

    try {
      // Test JWT token creation and validation
      const payload = { userId: 'test-user', role: 'admin' };
      const token = await this.createJWTToken(payload);
      
      // Verify token is valid
      const isValid = await this.validateJWTToken(token);
      if (!isValid) {
        result.status = 'FAILED';
        result.vulnerabilities.push('JWT validation failed');
        result.recommendations.push('Check JWT validation implementation');
      }

      // Test invalid token rejection
      const invalidToken = token + 'invalid';
      const isInvalidValid = await this.validateJWTToken(invalidToken);
      if (isInvalidValid) {
        result.status = 'FAILED';
        result.vulnerabilities.push('Invalid token accepted');
        result.recommendations.push('Ensure invalid tokens are rejected');
      }

    } catch (error) {
      result.status = 'FAILED';
      result.vulnerabilities.push(`JWT validation test failed: ${error.message}`);
      result.recommendations.push('Review JWT implementation');
    }

    return result;
  }

  private async testRBAC(): Promise<SecurityTestResult> {
    const result: SecurityTestResult = {
      name: 'Role-Based Access Control',
      category: 'Authorization',
      status: 'PASSED',
      details: 'RBAC system implemented with proper permission validation',
      vulnerabilities: [],
      recommendations: []
    };

    try {
      // Test role-based permission checks
      const testCases = [
        { role: 'admin', permission: 'manage_users', expected: true },
        { role: 'analyst', permission: 'manage_users', expected: false },
        { role: 'readonly', permission: 'view_dashboard', expected: true },
        { role: 'readonly', permission: 'manage_users', expected: false }
      ];

      for (const testCase of testCases) {
        const hasPermission = await this.checkPermission(testCase.role, testCase.permission);
        
        if (hasPermission !== testCase.expected) {
          result.status = 'FAILED';
          result.vulnerabilities.push(`RBAC check failed for role ${testCase.role} and permission ${testCase.permission}`);
          result.recommendations.push('Review RBAC permission validation logic');
        }
      }

    } catch (error) {
      result.status = 'FAILED';
      result.vulnerabilities.push(`RBAC test failed: ${error.message}`);
      result.recommendations.push('Review RBAC implementation');
    }

    return result;
  }

  private async testSQLInjectionPrevention(): Promise<SecurityTestResult> {
    const result: SecurityTestResult = {
      name: 'SQL Injection Prevention',
      category: 'Input Validation',
      status: 'PASSED',
      details: 'SQL injection prevention implemented with parameterized queries',
      vulnerabilities: [],
      recommendations: []
    };

    try {
      // Test SQL injection attempts
      const maliciousInputs = [
        "'; DROP TABLE users; --",
        "1' OR '1'='1",
        "1; DELETE FROM users WHERE 1=1; --",
        "admin'--"
      ];

      for (const input of maliciousInputs) {
        const isBlocked = await this.testSQLInjection(input);
        
        if (!isBlocked) {
          result.status = 'FAILED';
          result.vulnerabilities.push(`SQL injection not blocked for input: ${input}`);
          result.recommendations.push('Ensure parameterized queries are used');
        }
      }

    } catch (error) {
      result.status = 'FAILED';
      result.vulnerabilities.push(`SQL injection test failed: ${error.message}`);
      result.recommendations.push('Review SQL injection prevention implementation');
    }

    return result;
  }

  // Helper methods for testing
  private async hashPassword(password: string): Promise<string> {
    // Implement password hashing test
    return 'hashed_password';
  }

  private async verifyPassword(password: string, hash: string): Promise<boolean> {
    // Implement password verification test
    return true;
  }

  private async createJWTToken(payload: any): Promise<string> {
    // Implement JWT token creation test
    return 'jwt_token';
  }

  private async validateJWTToken(token: string): Promise<boolean> {
    // Implement JWT validation test
    return true;
  }

  private async checkPermission(role: string, permission: string): Promise<boolean> {
    // Implement permission check test
    return role === 'admin' || (role === 'readonly' && permission === 'view_dashboard');
  }

  private async testSQLInjection(input: string): Promise<boolean> {
    // Implement SQL injection test
    return true; // Should return true if injection is blocked
  }

  private async identifyVulnerabilities(): Promise<SecurityVulnerability[]> {
    // Implement vulnerability identification
    return [];
  }

  private async validateCompliance(): Promise<ComplianceResult[]> {
    // Implement compliance validation
    return [];
  }

  private async generateRecommendations(
    testResults: SecurityTestResult[],
    vulnerabilities: SecurityVulnerability[],
    complianceResults: ComplianceResult[]
  ): Promise<SecurityRecommendation[]> {
    // Implement recommendation generation
    return [];
  }

  private calculateOverallScore(
    testResults: SecurityTestResult[],
    vulnerabilities: SecurityVulnerability[],
    complianceResults: ComplianceResult[]
  ): number {
    // Implement overall score calculation
    return 95.0; // Placeholder
  }
}
```

**Security Controls:**
- **Testing**: Comprehensive security testing framework
- **Validation**: Security validation and verification
- **Quality**: Security quality assurance processes
- **Reporting**: Security testing and compliance reporting
- **Improvement**: Continuous security improvement

---
*Generated by BMAD-METHOD‚Ñ¢ Security Architect Agent*
EOF

    success "Security architecture created. See $DOCS_DIR/architecture.md"
}

# Function to display help
show_help() {
    echo "BMAD-METHOD‚Ñ¢ Workflow Script for TPDP Security Project"
    echo ""
    echo "Usage: $0 <command>"
    echo ""
    echo "Commands:"
    echo "  setup                 Setup BMAD-METHOD‚Ñ¢ structure"
    echo "  planning-phase        Initialize planning phase"
    echo "  development-phase    Initialize development phase"
    echo "  security-analysis     Run security analysis"
    echo "  create-prd           Create security PRD"
    echo "  create-architecture  Create security architecture"
    echo "  help                 Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 setup"
    echo "  $0 planning-phase"
    echo "  $0 security-analysis"
    echo ""
    echo "BMAD-METHOD‚Ñ¢ transforms TPDP security development through:"
    echo "  1. Agentic Planning (Security Analyst + PM + Architect + QA)"
    echo "  2. Context-Engineered Development (Scrum Master + Dev + QA)"
    echo "  3. Eliminates planning inconsistency and context loss"
    echo ""
}

# Main script logic
main() {
    case "$1" in
        "setup")
            setup_bmad_structure
            ;;
        "planning-phase")
            init_planning_phase
            ;;
        "development-phase")
            init_development_phase
            ;;
        "security-analysis")
            run_security_analysis
            ;;
        "create-prd")
            create_security_prd
            ;;
        "create-architecture")
            create_security_architecture
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            echo "BMAD-METHOD‚Ñ¢ Workflow Script for TPDP Security Project"
            echo ""
            echo "Usage: $0 <command>"
            echo ""
            echo "Commands:"
            echo "  setup                 Setup BMAD-METHOD‚Ñ¢ structure"
            echo "  planning-phase        Initialize planning phase"
            echo "  development-phase    Initialize development phase"
            echo "  security-analysis     Run security analysis"
            echo "  create-prd           Create security PRD"
            echo "  create-architecture  Create security architecture"
            echo "  help                 Show this help message"
            echo ""
            echo "For more information, run: $0 help"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"